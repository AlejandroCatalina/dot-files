<p><a href="http://clojurewest.org">Clojure/West</a> was a blast and I&#39;m happy that
Michael Fogus&#39;s joke became a
<a href="http://blog.fogus.me/2013/02/20/confo/">reality</a> with 140+
attendees. All the presentations were great, in particular I enjoyed
<a href="http://twitter.com/acfoltzer">Adam Foltzer&#39;s</a> talk on implementing a
logic programming system in Haskell,
<a href="http://twitter.com/objcmdo">Ryan Senior&#39;s</a> tutorial on the new
finite domain functionality in core.logic, and of course Dan Friedman
and Will Byrd&#39;s relational
<a href="http://matt.might.net/articles/cesk-machines/">CESK machine</a>.</p>

<p><a href="http://twitter.com/nadamin">Nada Amin&#39;s</a> talk on
<a href="http://arxiv.org/abs/cs/0609062">nominal logic programming</a> was
stellar but I think it may have seemed a bit too far into the deep end
for some of the attendees. In this post I&#39;d like to explain some of
the interesting bits of her talk at a much slower pace. I hope you&#39;ll
see that nominal logic programming is really a simple idea in the end.</p>

<p>Whether we know it or not, when we use a functional programming
language we benefit heavily from the formalism of the lambda calculus
(now would be a good time to re-read
 <a href="http://swannodette.github.com/Nominal%20Logic/2013/02/08/the-simply-typed-lambda-calculus-in-20-lines-redux/">my earlier post</a>). We&#39;re
going to go further by actually <em>running</em> bits of the formalism. I recommend cloning
<a href="http://github.com/namin/minikanren-confo/">Nada&#39;s talk repo</a> firing
up your favorite REPL, and we&#39;ll step through it together.</p>

<p>Again the idea here is to build up an informal understanding (which is
all I have to offer anyway ;)</p>

<p>Let&#39;s look at the very first example:</p>

<pre>
(run* [q]
  (nom/fresh [a b]
    (== (lam a a) (lam b b))))
</pre>

<p>If you&#39;ve used miniKanren or core.logic before you may notice that we
seem to have a new primitive <code>nom/fresh</code>. This primitive is similar to
<code>fresh</code> but instead of creating fresh logic variables, it creates
fresh <em>noms</em>. What are noms? They are like identifiers/names in
programming languages. What they buy us over traditional logic
variables is that we can use them to reason about scope.</p>

<p>But before we get into scope let&#39;s break down what the program above
means. If we were to write this in a more standard notation we might
write it in following manner:</p>

<div>
$$\lambda a.a \equiv_{\alpha} \, \lambda b.b$$
</div>

<p>Testing functions for equality is tricky business, however we can
overload unification in the core.logic program above to mean a
more limited form of function equality - up to alpha equivalence.</p>

<p>By
<a href="http://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence">alpha equivalence</a>
we simply mean that the two lambda terms are equal up to the names - we
can see here the names (or <em>noms</em>) don&#39;t really matter.</p>

<p>In fact if we run this example, and I recommend that you do, we&#39;ll get
back $_$$_0$, meaning that this set of constraints is
satisfiable!</p>

<p>Now consider the following example:</p>

<pre>
(run* [q]
  (nom/fresh [a b c]
    (== (lam a a) (lam b c))))
</pre>

<p>Will this work? No.</p>

<p>$\mathtt{c}$ occurs <em>free</em> in the second lambda expression. We don&#39;t
know where that $\mathtt{c}$ comes from, so these terms can&#39;t possibly
represent the same thing. Thus:</p>

<div>
$$\lambda a.a \not\equiv_{\alpha} \, \lambda b.c$$
</div>

<p>If we run the program above we&#39;ll get the expected dreaded empty list
which lets us know the constraints cannot be satisfied.</p>

<p>Let&#39;s break this down further, $\mathtt{lam}$ is actually hiding away the
nominal logic programming primitives, if we dig in we&#39;ll see that it
is defined in the following manner:</p>

<pre>
(defn lam [x e]
  `(~'fn ~(nom/tie x e)))
</pre>

<p>It just takes two values, a nom and an expression. It then constructs a
Clojure sequence which which starts with the symbol
$\mathtt{fn}$. This is just to ensure that the output is comprehensible
and importantly - executable Clojure code. The body of the function is
something we haven&#39;t see before $\mathtt{nom/tie}$.</p>

<p>$\mathtt{nom/tie}$ takes a nom and an expression and it <em>constructs a
scope</em>. In this scope, the nom $\mathtt{x}$ will be bound! This is
precisely what we need.</p>

<p>In the next posts we&#39;ll start translating the paper
ideas of the first post into <em>runnable</em> ideas.</p>
