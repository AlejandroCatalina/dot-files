<style>
  #post ol {
    position: relative;
    left: 200px;
    font-size: 18px;
    line-height: 1.5em;
    margin: 30px 0 30px 0;
  }
  #resp {
    font-size: 18px;
    text-align: center;
    font-family: Georgia;
    margin: 30px 0;
  }
  #ex0-ui, #ex1-ui, #ex2-ui {
    border: none !important;
    padding: 0 !important;
    margin: 0 !important;
  }
  #post #ex0 {
    height: 90px;
    background-color: #efefef;
    border: none;
    padding-top: 20px;
  }
  #post #ex1 {
    height: 110px;
    background-color: #efefef;
    border: none;
    padding-top: 20px;
  }
  #post .example pre {
    background-color: transparent;
    position: relative;
    left: 200px;
    font-size: 18px;
  }
  #post #ex2 {
    height: 150px;
    background-color: #efefef;
    border: none;
    padding-top: 20px;
  }
  #post #ex2 ul {
    position: relative;
    background: white;
    width: 170px;
    left: 190px;
    border: 1px solid #ccc;
    border-radius: 4px;
    -webkit-border-radius: 4px;
    -moz-border-radius: 4px;
  }
  #post #ex2 li {
    cursor: pointer;
    list-style: none;
    padding: 4px 4px 4px 8px;
    border-bottom: 1px solid #ccc;
  }
  #post #ex2 li.highlighted {
    background-color: #ccccff;
  }
  #post #ex2 li.selected {
    background-color: #ffcccc;
  }
  #post #ex2 li.highlighted.selected {
    background-color: #ffccff;
  }
</style>

<p>When architecting user interface components programmers usually engage
in copious amounts of
<a href="http://www.infoq.com/presentations/Simple-Made-Easy">complecting</a>. However
we shouldn&#39;t be blamed as traditional approaches do not make
the boundaries clear. In the
<a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/">last post</a>
I alluded to the possibility that <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> provides
opportunities to pull things apart and that there might be real value
in such a separation of concerns.</p>

<p>I believe there are three main elements not called Model View
Controller (nor any other arbitrary variation on that tired old
theme). The trichotomic design I&#39;d like to suggest is more
fundamental:</p>

<ol>
<li>Event stream processing</li>
<li>Event stream coordination</li>
<li>Interface representation</li>
</ol>

<p>When you look at UI components written in good object oriented style
whether in Java, Objective-C, or JavaScript you nearly always find
these three clear and distinct aspects complected together. In a
traditional design you would have event stream processing provided by
a base class or mixin. By subclassing you can provide custom interface
representations. When it comes to the most complex and application
specific code - event stream coordination - many well intentioned
components devolve into an
<a href="https://github.com/jquery/jquery-ui/blob/master/ui/autocomplete.js">async mess made worse by the requisite complex state management</a>.</p>

<p>Ok, but what value can we derive if we take the time to pull these
elements apart as described?</p>

<div id="resp">
    Responsive design
</div>

<p>Despite Cascading Style Sheets&#39; many flaws, with
<a href="http://www.w3.org/TR/css3-mediaqueries/">media queries</a> designers can
flexibly address many different clients in an open ended manner -
define your base styles and then override only those parts relevant
for a particular client.</p>

<p>User interface programmers don&#39;t have the luxury of CSS for complex
interactions yet are faced with the same rapidly growing heterogenous
population of clients - components written in a traditional style
either bloat to address fragmentation or libraries provide incompatible
versions of the same conceptual components like
<a href="http://jqueryui.com">this</a> and <a href="http://jquerymobile.com">that</a>.</p>

<p>What would it look like to pull apart these concerns? And once we pull
them apart do we actually have a more responsive system?</p>

<p>Rather than tackling a complex component like a non-toy autocompleter
in its entirety as I suggested in the last post, instead I&#39;d like
focus on how we can productively apply the separation of concerns to a
subcomponent of the autocompleter - the drop down menu.</p>

<p>First let&#39;s consider <strong>interface representations</strong> for our submenu
process. In order to be responsive we&#39;d like to make no commitments at
all - the only thing we want to describe is a protocol that different
concrete representations must conform to. In ClojureScript this is
simple to express:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defprotocol IHighlightable
  (-highlight! [list n])
  (-unhighlight! [list n]))
</code></pre></div>
<p>Done.</p>

<p>We&#39;re now free to use any visual representation we please and we&#39;ll
see this in a moment.</p>

<p>What about <strong>event stream processing</strong>? </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defn key-events [prevent-default?]
  (-&gt;&gt; (r/listen js/document :keydown prevent-default?)
    (r/map key-event-&gt;keycode)
    (r/filter KEYS)
    (r/map key-&gt;keyword)))
</code></pre></div>
<p>Again we see the
<a href="http://reactive-extensions.github.io/RxJS/">reactive</a> approach. We
take the stream of raw key events, map them into key codes, filter
codes that don&#39;t correspond to the selection process controls (in this
case up arrow, down arrow, and enter) and then map those into the
messages that the highlighter process actually listens for: <code>:next</code>,
<code>:previous</code>, <code>:clear</code>, or a number. <em>This is our process
protocol</em>.</p>

<p>It&#39;s critical that the currency of event coordination be at higher
level than concrete events sources like key presses and mouse
movement - this will allow our system to be responsive. Another
benefit that falls out of designing an abstract stream protocol
is that we don&#39;t need to complicate our program with superflous
coordination APIs.</p>

<p>Just to drive the point home one more time - <em>the highlighter process
does not care how the stream events are constructed</em>. They could just
as easily come from a mouse, a finger on a touch screen, a
<a href="https://www.leapmotion.com/">Leap Motion</a> device, or a Clojure vector
(think testing).</p>

<p>Now what about <strong>event stream coordination</strong>?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defn highlighter [in list]
  (let [out (chan)]
    (go (loop [highlighted ::none]
          (let [e (&lt;! in)]
            (if (or (#{:next :previous :clear} e) (number? e))
              (let [highlighted (handle-event e highlighted list)]
                (&gt;! out highlighted)
                (recur highlighted))
              (do (&gt;! out e)
                (recur highlighted))))))
    out))
</code></pre></div>
<p><code>highlighter</code> takes two arguments, <code>in</code> - an input channel of events,
and <code>list</code> - a UI rendering target. We enter a loop with one piece of
local state - the current highlighted index. We process every event we
receive from <code>in</code>. If we have an event we can handle we side effect
the rendering target accordingly. Note if we cannot handle the message
we just write it to <code>out</code>, more on this later.</p>

<p>Lets see this in action. Place your mouse into the grey area (you may
need to click) and trying pressing the up and down arrows. <em>NOTE:
mousing over the grey areas will steal your key presses, simply mouse
out to restore normal behavior</em>:</p>

<div id="ex0" class="example">
   <pre id="ex0-ui" style="border: none;"></pre>
</div>

<p>It seems we have a text based interface similar to the kind you might
find in a Rogue-like. In fact our rendering surface is a JavaScript
array!</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(let [ui (array &quot;   Alan Kay&quot;
                &quot;   J.C.R. Licklider&quot;
                &quot;   John McCarthy&quot;)]
  (create-example &quot;ex0&quot;
    key-events
    (fn []
      (dom/set-text! (dom/by-id &quot;ex0-ui&quot;) (.join ui &quot;\n&quot;)))
    (fn [events]
      (highlighter events ui))))
</code></pre></div>
<p>With each key press we mutate this array, concatenate it into a
string, and render that into a <code>pre</code> tag. We&#39;ll see in a moment that
all of this code can be reused without modification to target an HTML
interface.</p>

<p>But before we do that we should address a deficiency - we cannot
select anything in the submenu. Let&#39;s add another <strong>interface
representation</strong> protocol:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defprotocol ISelectable
  (-select! [list n])
  (-unselect! [list n]))
</code></pre></div>
<p>We don&#39;t need additional <strong>event stream processing</strong>, the stream above
produces all the information we need - it includes <code>:select</code> events
and the highlighter simply passes it along since it cannot handle that
message itself. We can move straight away to <strong>event stream
coordination</strong>:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defn selector [in list data]
  (let [out (chan)]
    (go (loop [highlighted ::none selected ::none]
          (let [e (&lt;! in)]
            (if (= e :select)
              (do
                (when (number? selected)
                  (-unselect! list selected))
                (-select! list highlighted)
                (&gt;! out [:select (nth data highlighted)])
                (recur highlighted highlighted))
              (do
                (&gt;! out e)
                (if (or (= e ::none) (number? e))
                  (recur e selected)
                  (recur highlighted selected)))))))
    out))
</code></pre></div>
<p>This looks remarkably similar to <code>highlighter</code>, in fact we&#39;re feeding
the output of <code>highlighter</code> into <code>selector</code>! Again place your mouse
over the grey area and press either the up arrow, down arrow, or enter
keys. You&#39;ll now see that selections are preserved:</p>

<div id="ex1" class="example">
   <pre id="ex1-ui" style="border: none;"></pre>
</div>

<p>We can inherit functionality just by composing streams. We simply pass
along the messages we don&#39;t understand. This all sounds eerily
familiar.</p>

<p>Because we have committed to so little we can now reap the rewards of
the design, what follows is an HTML submenu component that uses all of
the prior logic - the only difference is that the initial stream
includes hover information (which are converted into integers) from
the list items as well as mouse clicks (which are converted into
<code>:select</code>s). Put your mouse in the grey area - note that hovering,
clicking, arrows keys, and enter all work.</p>

<div id="ex2" class="example">
   <ul id="ex2-list">
      <li>Gravity's Rainbow</li>
      <li>Swann's Way</li>
      <li>Absalom, Absalom</li>
      <li>Moby Dick</li>
   </ul>
</div>

<p>By teasing apart the architecture of the UI components we now have a
truly modular and <em>responsive</em> system. It&#39;s also pleasantly small for the
amount of flexibility we get in return.</p>

<p>In the next post we&#39;ll see how to put the result of this post and the
original post into a cohesive whole.</p>

<p>You can see all the code for this post <a href="http://github.com/swannodette/swannodette.github.com/blob/master/code/blog/src/blog/responsive/core.cljs">here</a>.</p>

<script type="text/javascript" src="/assets/js/resp.js"></script>
