<p>This article continues the series about <a href="/2014/03/12/font-locking-in-emacs.html">Font Locking in Emacs</a> with
a look at search-based fontification with regular expressions in
<a href="el-variable:font-lock-keywords"><code class="highlighter-rouge">font-lock-keywords</code></a>.  If you are new, you may want to read the first
article on <a href="/2014/03/12/syntactic-fontification-in-emacs.html">Syntactic Fontification in Emacs</a> first.</p>

<p>Search-based fontification is the main workhorse of font locking.  It is used in
any major mode to highlight the specific syntax of the target language.</p>

<p>The concept is quite easy, the difficulty however is in the right choice of the
regular expressions, and the matching of target syntax to the generic font lock
faces provided by Emacs.</p>

<p>This article illustrates the basic principles of Search-based fontification.</p>

<h1 id="prerequisites">Prerequisites</h1>

<p>Before we can start to add font lock to our major mode, we’ll have to go through
some quite essential prerequisites first:</p>

<ol>
  <li>Obtain a <em>language reference</em>, and read it <em>systematically</em> to extract the
relevant language syntax.  Don’t try to start with ad-hoc keywords based on
your intuitive understanding of the language.  You’ll sooner or later fail on
corner-cases.</li>
  <li>
    <p>Familiarize yourself with the <a href="el-function:rx"><code class="highlighter-rouge">rx</code></a> macro.  We’ll use it to turn
regexp-monsters like this<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>:</p>

    <p><code class="highlighter-rouge">cl
 "\\(/\\(?:[^\n/\\]\\|\\\\.\\)*/\\)"
</code></p>

    <p>into readable and commented sexps like this:</p>

    <p><code class="highlighter-rouge">cl
 (rx (group
      ;; A regular expression literal is delimited by
      ;; slashes
      "/"
      (zero-or-more
       (or
        ;; Inside a regexp, a character is either
        ;; escaped with a backslash, in which case it
        ;; looses any special meaning and can't
        ;; terminate the regexp anymore,…
        (and "\\" not-newline)
        ;; …or any non-special character, namely not a
        ;; slash (this would end the sexp), not a
        ;; backslash (which would escape the subsequent
        ;; character), or a literal new-line (which is
        ;; illegal in a regexp)
        (not (any "/" "\\" "\n"))))
        "/"))
</code></p>
  </li>
  <li>
    <p>Familiarize yourself with <a href="el-function:re-builder"><code class="highlighter-rouge">re-builder</code></a> command.  It’s a great tool to
interactively develop regular expressions in a specific buffer.  For the
purpose of developing font lock keywords with <a href="el-function:rx"><code class="highlighter-rouge">rx</code></a>, change it’s
syntax, either with <kbd>C-c TAB</kbd> in re-builder, or by adding the
following to your <code class="highlighter-rouge">init.el</code>:</p>

    <p><code class="highlighter-rouge">cl
 (eval-after-load 're-builder '(setq reb-re-syntax 'rx))
</code></p>
  </li>
</ol>

<h1 id="setup-boilerplate">Setup boilerplate</h1>

<p>We’ll need a little boilerplate before we can start with the actual keywords.
We declare a variable to store the keywords, and tell Emacs to look for keywords
in this variable, by setting <a href="el-variable:font-lock-defaults"><code class="highlighter-rouge">font-lock-defaults</code></a> in our major mode
definition:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nv">defconst</span> <span class="nv">puppet-font-lock-keywords</span> <span class="no">nil</span>
  <span class="s">"Font lock keywords for Puppet Mode."</span><span class="p">)</span>

<span class="p">(</span><span class="nv">define-derived-mode</span> <span class="nv">puppet-mode</span> <span class="nv">prog-mode</span> <span class="s">"Puppet"</span> <span class="p">()</span>
  <span class="s">"Major mode for editing Puppet manifests.

\\{puppet-mode-map}"</span>
  <span class="c1">;; …</span>
  <span class="c1">;; Font locking</span>
  <span class="p">(</span><span class="k">setq</span> <span class="nv">font-lock-defaults</span> <span class="o">'</span><span class="p">((</span><span class="nv">puppet-font-lock-keywords</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">))</span>
  <span class="c1">;; …</span>
  <span class="p">)</span>
</code></pre>
</div>

<p><a href="el-variable:font-lock-defaults"><code class="highlighter-rouge">font-lock-defaults</code></a> is a list with initial settings for
fontification, with the following elements:</p>

<ol>
  <li>A list of variables holding keywords.  Typically this list has just a single
element:  The name of the variable which holds our keywords<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>.</li>
  <li>A boolean indicating whether to <em>disable</em>
<a href="/2014/03/12/syntactic-fontification-in-emacs.html">syntactic fontification</a>, and only use keywords for
fontification.  Since syntactic fontification conveniently handles strings
and comments in Puppet Mode, we definitely don’t want to disable it, so we
give <code class="highlighter-rouge">nil</code> here.</li>
  <li>A boolean indicating whether our keywords are case-insensitive.  Since Puppet
Mode has case-sensitive identifiers, we give <code class="highlighter-rouge">nil</code> to match the case in our
keywords.</li>
</ol>

<p>These are the most important settings.  There are some optional elements for
additional settings, such as a special syntax table for fontification, but these
are rarely needed, so we’ll not discuss them here.  Take a look at the docstring
of <a href="el-variable:font-lock-defaults"><code class="highlighter-rouge">font-lock-defaults</code></a> for more information.</p>

<h1 id="defining-keywords">Defining keywords</h1>

<p>The contents of our keyword variable <code class="highlighter-rouge">puppet-font-lock-keywords</code> is a list,
where each item is another list describing a single syntactic construct to
highlight.</p>

<p>The following is a little excerpt of the actual font lock keywords used by
Puppet Mode<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nv">defconst</span> <span class="nv">puppet-font-lock-keywords</span>
  <span class="o">`</span><span class="p">(</span>
    <span class="c1">;; Regular expression literals</span>
    <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nv">rx</span> <span class="s">"/"</span>
          <span class="p">(</span><span class="nv">zero-or-more</span>
           <span class="p">(</span><span class="nb">or</span>
            <span class="c1">;; Not at the end of the regexp</span>
            <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">any</span> <span class="s">"/"</span> <span class="s">"\\"</span> <span class="s">"\n"</span><span class="p">))</span>
            <span class="c1">;; Any escaped character</span>
            <span class="p">(</span><span class="nb">and</span> <span class="s">"\\"</span> <span class="nv">not-newline</span><span class="p">)))</span>
          <span class="s">"/"</span><span class="p">)</span>
     <span class="mi">0</span> <span class="ss">'puppet-regular-expression-literal</span><span class="p">)</span>

    <span class="c1">;; Puppet keywords</span>
    <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nv">rx</span> <span class="nv">symbol-start</span>
          <span class="p">(</span><span class="nb">or</span> <span class="s">"and"</span> <span class="s">"case"</span> <span class="s">"class"</span> <span class="s">"default"</span> <span class="s">"define"</span>
              <span class="s">"else"</span> <span class="s">"elsif"</span> <span class="s">"false"</span> <span class="s">"if"</span> <span class="s">"in"</span> <span class="s">"import"</span>
              <span class="s">"inherits"</span> <span class="s">"node"</span> <span class="s">"or"</span> <span class="s">"true"</span> <span class="s">"undef"</span>
              <span class="s">"unless"</span><span class="p">)</span>
          <span class="nv">symbol-end</span><span class="p">)</span>
     <span class="mi">0</span> <span class="nv">font-lock-keyword-face</span><span class="p">)</span>

    <span class="c1">;; Class and Defined Types</span>
    <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nv">puppet-rx</span> <span class="p">(</span><span class="nv">symbol-start</span>
                  <span class="p">(</span><span class="nb">or</span> <span class="s">"class"</span> <span class="s">"define"</span><span class="p">)</span>
                  <span class="nv">symbol-end</span><span class="p">)</span>
                 <span class="p">(</span><span class="nv">one-or-more</span> <span class="nv">space</span><span class="p">)</span>
                 <span class="c1">;; The resource name</span>
                 <span class="p">(</span><span class="nv">group</span> <span class="nv">symbol-start</span>
                        <span class="c1">;; Optional top-level scope</span>
                        <span class="p">(</span><span class="nv">optional</span> <span class="s">"::"</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">zero-or-more</span>
                         <span class="p">(</span><span class="nv">any</span> <span class="s">"a-z"</span><span class="p">)</span>
                         <span class="p">(</span><span class="nv">zero-or-more</span> <span class="p">(</span><span class="nv">any</span> <span class="s">"a-z"</span> <span class="s">"0-9"</span> <span class="s">"_"</span><span class="p">))</span>
                         <span class="s">"::"</span><span class="p">)</span>
                         <span class="c1">;; Nested sub-scopes</span>
                         <span class="p">(</span><span class="nv">any</span> <span class="s">"a-z"</span><span class="p">)</span>
                         <span class="p">(</span><span class="nv">zero-or-more</span> <span class="p">(</span><span class="nv">any</span> <span class="s">"a-z"</span> <span class="s">"0-9"</span> <span class="s">"_"</span><span class="p">))</span>
                         <span class="nv">symbol-end</span><span class="p">))</span>
     <span class="mi">1</span> <span class="nv">font-lock-type-face</span><span class="p">)))</span>
</code></pre>
</div>

<p>We specify three keywords:</p>

<ol>
  <li><a href="https://docs.puppetlabs.com/puppet/3/reference/lang_datatypes.html#regular-expressions">Regular expression literals</a></li>
  <li><a href="https://docs.puppetlabs.com/puppet/3/reference/lang_reserved.html#reserved-words">Puppet keywords</a></li>
  <li><a href="https://docs.puppetlabs.com/puppet/3/reference/lang_classes.html">Class</a> and <a href="https://docs.puppetlabs.com/puppet/3/reference/lang_defined_types.html">type</a> definitions</li>
</ol>

<p>Each keyword is a list on its own, with the following elements:</p>

<ol>
  <li>A regular expression to match the syntactic construct to fontify.</li>
  <li>A group index, matching a number group in the regular expression.  Zero
stands for the entire match.</li>
  <li>A Lisp <em>expression</em> whose value is the face to use.</li>
</ol>

<h2 id="ordering">Ordering</h2>

<p>Font lock keywords are processed in order of appearance.  Each keyword will
<em>not</em> match in text which is already fontified by syntactic fontification or
earlier font lock keywords<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>.  Hence <em>the order of keywords matters</em>.</p>

<p>For instance, with our example keywords Emacs will highlight all keywords
<em>first</em>, before classes and defined types.</p>

<p>This has a couple of advantages:</p>

<ol>
  <li>We do not need to take care for strings and comments in our font lock
keywords.  As these are already fontified by
<a href="/2014/03/12/syntactic-fontification-in-emacs.html">syntactic fontification</a>, our expressions will never match
inside strings or comments, so a keyword inside a comment will never get
fontified.</li>
  <li>We can rely on earlier font lock keywords.  In our second expression, we do
not need to explicitly highlight <code class="highlighter-rouge">class</code> and <code class="highlighter-rouge">define</code> anymore, because
because the earlier expression for Puppet keywords has already fontified
these.</li>
</ol>

<p>Consequently the order of keywords must be <em>carefully</em> constructed to avoid
matching in the wrong context.  Notably, we must specify the font lock keyword
for regular expression literals <em>first</em>, before the font lock keyword for Puppet
keywords.</p>

<p>Consider the following example, where the Puppet keyword <code class="highlighter-rouge">true</code> appears inside a
regular expression literal:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">if</span> <span class="nv">$foo</span> <span class="o">=~</span> <span class="sr">/</span><span class="se">\A</span><span class="si">(</span><span class="sr">?i:true|yes</span><span class="si">)</span><span class="se">\z</span><span class="sr">/</span> <span class="p">{</span>
  <span class="nf">notice</span><span class="p">(</span><span class="s1">'You speak the truth!'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In this context the keyword is not a keyword, but just literal text in the
pattern.  If the keyword for regular expression literals didn’t go first, <code class="highlighter-rouge">true</code>
would be fontified as keyword and not as regular expression literal in this
example.</p>

<h2 id="regular-expressions">Regular expressions</h2>

<p>Our regular expressions for keywords and definitions are pretty straight-forward
translations from the list of <a href="https://docs.puppetlabs.com/puppet/3/reference/lang_reserved.html#reserved-words">Puppet keywords</a>, the description of Classes_
and <a href="https://docs.puppetlabs.com/puppet/3/reference/lang_defined_types.html">Defined Types</a> and the pattern for <a href="https://docs.puppetlabs.com/puppet/3/reference/lang_reserved.html#classes-and-types">valid resource names</a> in the Puppet
language references.</p>

<p>The expression for regular expression literals however are an approximation of
<a href="https://docs.puppetlabs.com/puppet/3/reference/lang_datatypes.html#regular-expressions">Regular expression literals</a>, which matches essentially any text between a
slash and the next unescaped slash.  This pattern is not perfect, and will match
regular expressions at inappropriate places, but as far as fontification is
considered, this is a reasonable trade-off.</p>

<p>We could reduce the chance of mismatched regular expressions by limiting the
keyword to match only in cases where regular expressions are actually permitted,
but this would significantly increase the complexity of our keywords and goes
beyond the scope of this article<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>.</p>

<h3 id="symbol-boundaries">Symbol boundaries</h3>

<p>We use the special forms <code class="highlighter-rouge">symbol-start</code> and <code class="highlighter-rouge">symbol-end</code> to make sure that our
expressions only match entire symbols.  These special forms match the empty
string at the beginning and end of a symbol.</p>

<p>This prevents our expressions from matching keywords which appear in the middle
of another identifier, e.g. in a function name.  In the following example code,
our patterns will match the <code class="highlighter-rouge">define</code> keyword in the type definition, but not
“define” in call of the <code class="highlighter-rouge">defined</code> function <sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">define</span> <span class="nf">foo</span><span class="p">(</span><span class="nv">$bar</span> <span class="err">=</span> <span class="nv">$title</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="o">!</span><span class="nf">defined</span><span class="p">(</span><span class="nc">Package</span><span class="p">[</span><span class="nv">$bar</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">package</span> <span class="p">{</span> <span class="nv">$bar</span><span class="p">:</span> <span class="py">ensure</span> <span class="p">=&gt;</span> <span class="n">installed</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="grouping">Grouping</h3>

<p>Our first two expressions for regexp literals and keywords do not have match
groups, since in both cases we simply want to highlight the entire construct.
Hence we give the match index <code class="highlighter-rouge">0</code> to highlight the entire match of the regular
expression.</p>

<p>In the third expression for class and type definitions however we only want to
highlight the name of the new class or type, but not the preceding keyword,
which was already handled by our previous expression for Puppet keywords.
Hence, we put the pattern for the class and type name into a match group, and
give its index <code class="highlighter-rouge">1</code> to only apply the highlighting to the text matched by this
group.</p>

<h2 id="faces">Faces</h2>

<p>The face is arguably the most important part in a font lock keyword.  It’s what
the user will ultimately see when using your mode.  Thus, the choice of good
faces is crucial for good fontification.</p>

<h3 id="standard-faces">Standard faces</h3>

<p>Luckily, Emacs provides a good set of <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Faces-for-Font-Lock.html#Faces-for-Font-Lock">standard font lock faces</a> for various
common syntax elements.  We use two of these faces in our keywords:</p>

<p><a href="el-variable:font-lock-keyword-face"><code class="highlighter-rouge">font-lock-keyword-face</code></a>
  ~ A face for the keywords of programming languages</p>

<p><a href="el-variable:font-lock-type-face"><code class="highlighter-rouge">font-lock-type-face</code></a>
  ~ A face for names of types and classes</p>

<p>Font lock provides a lot more faces for comments, strings, constants, variable
names, function names, builtins, preprocessor instructions, and many more.</p>

<p>You should use the standard faces whenever possible.  It’s not only easier for
you to just pick an appropriate standard face, it’s also good for your users if
your mode is a good Emacs citizen in this regard:</p>

<ul>
  <li>Fontification will look the same across different modes.  A string, a comment
or a keyword always look the same, regardless of whether they are in C++ code,
Python code, or Emacs Lisp code.</li>
  <li>Color themes will automatically affect your mode.  Color themes just need to
set the standard faces to style fontification in any programming language
Emacs has a mode for, and users can install new color themes without having to
care for whether a theme supports your specific mode or not.</li>
</ul>

<h3 id="custom-faces">Custom faces</h3>

<p>Sometimes the standard faces are just not appropriate, however.</p>

<p>In our example, we want to fontify regular expression literals, but there’s no
<code class="highlighter-rouge">font-lock-regexp-face</code>, and none of the existing standard faces are really
appropriate.  The best fit are still <a href="el-variable:font-lock-string-face"><code class="highlighter-rouge">font-lock-string-face</code></a> or
<a href="el-variable:font-lock-constant-face"><code class="highlighter-rouge">font-lock-constant-face</code></a>, but a user may probably want to distinguish
regular expressions from strings or constants.</p>

<p>For this purpose, we define a custom face with the name
<code class="highlighter-rouge">puppet-regular-expression-literal</code>, using <a href="el-function:defface"><code class="highlighter-rouge">defface</code></a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nv">defface</span> <span class="nv">puppet-regular-expression-literal</span>
  <span class="o">'</span><span class="p">((</span><span class="no">t</span> <span class="ss">:inherit</span> <span class="nv">font-lock-constant-face</span><span class="p">))</span>
  <span class="s">"Face for regular expression literals in Puppet."</span>
  <span class="ss">:group</span> <span class="ss">'puppet</span><span class="p">)</span>
</code></pre>
</div>

<p>The second argument to <a href="el-function:defface"><code class="highlighter-rouge">defface</code></a> takes our face definition.  The
syntax of face definitions is fairly intricate, and beyond the scope of this
article.  The docstring of <a href="el-function:defface"><code class="highlighter-rouge">defface</code></a> is a good start for more
information.</p>

<p>Our definition is very simple, however: The new face just inherits all its
attributes from the standard <a href="el-variable:font-lock-constant-face"><code class="highlighter-rouge">font-lock-constant-face</code></a>, so by default a
regular expression will look like a constant.</p>

<p>By inheriting from a standard font lock face, we play nicely with color themes
which only support the standard font lock faces, and we do not need to come up
with a good default style for our new face.  For these reasons, you should try
hard to find a built-in Emacs face to inherit from whenever you need to define
custom faces.</p>

<p>Nonetheless, users can customize our face <em>independently</em> from
<a href="el-variable:font-lock-constant-face"><code class="highlighter-rouge">font-lock-constant-face</code></a> to make regular expressions appear distinct
from constants if they desire, since it is a completely separate face.</p>

<p>The subsequent arguments in the face definition are a docstring, and standard
<a href="el-function:defcustom"><code class="highlighter-rouge">defcustom</code></a> arguments.  We just give <code class="highlighter-rouge">:group</code>, to make our custom
face appear in <kbd>M-x customize-group RET puppet</kbd>, where all the options
of Puppet Mode reside.</p>

<p>You’ll notice that unlike the standard faces our custom face doesn’t have the
suffix <code class="highlighter-rouge">-face</code>.  The Emacs Lisp reference recommends against this in
<a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Faces.html">Defining Faces</a>.</p>

<p>The standard faces however predate this convention, and keep their names for
backwards compatibility.  With regards to faces, you should <em>not</em> follow Font
Lock as a template.</p>

<h3 id="face-variables-versus-faces">Face variables versus faces</h3>

<p>When looking closely at our font lock keywords, you’ll notice that we specify
standard font lock face <em>without</em> quoting, whereas our custom face is quoted.</p>

<p>The reason is that font lock additionally defines <em>variables</em> for its faces.  A
comment in <code class="highlighter-rouge">font-lock.el</code> explains the background, and discourages this practice
for custom faces<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>:</p>

<blockquote>
  <p>Originally these variable values were face names such as <code class="highlighter-rouge">bold</code> etc.  Now we
create our own faces, but we keep these variables for compatibility and they
give users another mechanism for changing face appearance.  We now allow a
<em>facename</em> in <a href="el-variable:font-lock-keywords"><code class="highlighter-rouge">font-lock-keywords</code></a> to be any expression that returns a
face.  So the easiest thing is to continue using these variables, rather than
sometimes evalling <em>facename</em> and sometimes not.  sm.</p>
</blockquote>

<blockquote>
  <p>Note that in new code, in the vast majority of cases there is no need to
create variables that specify face names.  Simply using faces directly is
enough.  Font-lock is not a template to be followed in this area.</p>
</blockquote>

<p>Remember that the face part of a font lock keyword is not a face name, but
rather an <em>expression returning a face name</em>.  Hence, we can use the standard
face without quoting:  They are expressions, which evaluate to the value of the
variable, which in turn gives the face name…which—to make matters even
worse—has usually the same name as the variable.</p>

<p>For our custom faces however we do not define extra variables.  Hence we must
quote the face name, so that font lock uses it literally instead of trying to
evaluate it as variable.</p>

<p>While developing font lock keywords, you need to be aware of this small, but
important difference, lest you introduce subtle bugs into your code.</p>

<h1 id="limits">Limits</h1>

<p>We have seen that font lock keywords provide a simple, yet powerful facility to
add syntax highlighting for complex syntactic constructs.</p>

<p>There is a limitation to their power, however: They do not take the syntactic
context into account.  It is thus impossible to define a keyword which applies
only inside a comment, or only inside single-quoted strings.  For instance, font
lock keywords alone cannot highlight variable expansions inside strings, as in
Ruby or Puppet.</p>

<p>To handle such special syntax, which depends on the surrounding syntactic
context, you need to hook into the syntactic analyzer of Emacs, and explicitly
identify special constructs, a technique, which I’ll cover in a later post of
this series.</p>

<h1 id="conclusion">Conclusion</h1>

<p>Font lock keywords are <em>the</em> main part of fontification in Emacs.  Any mode uses
them to highlight the syntax of the corresponding language, and no mode can go
without them.  Good font lock keywords are crucial for good syntax highlighting
in Emacs.</p>

<p>However, for really stellar and awesome highlighting, which even goes as far as
fontifying variables or expressions inside strings, a major mode needs to go
beyond them, and use more intricate techniques of syntactic analysis.  More on
that in a later article.</p>

<p>So long</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>This is the expression for regular expression literals in Puppet. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Further elements may be used to give additional keywords for multiple
  levels of fontification, a feature which comes from days where fully
  featured fontification was too slow for most computers.  Higher levels
  contained more complex keywords, and a user would typically customize
  Emacs to enable the highest possible level their computers could handle.</p>

      <p>Nowadays however even the weakest computers easily cope with fully
  featured fontification, so most major modes just give a single level of
  fontification.  Most modern Emacs users don’t even know about this
  feature anymore. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Puppet Mode has a lot more font lock keywords of course.  However, these
  two are sufficient to illustrate the basic principles of font lock
  keywords. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Technically this is not completely true.  Keywords can be specified to
  override earlier fontification.  However, this should be used with care.
  Notably, it will cause font lock keywords to be applied within comments
  and strings as well, which is not generally desirable. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Puppet Mode will actually use a more intricate handling of regular
  expression literals, which takes the syntactic context into account, and
  also improves the behaviour of various navigation commands.  See
  <a href="https://github.com/lunaryorn/puppet-mode/pull/39">issue #39</a> for details. <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>In case you are wondering that <code class="highlighter-rouge">defined</code> is nonetheless highlighted in a
  Puppet buffer: In the real Puppet Mode, we have an additional font lock
  keyword to highlight all builtin functions of Puppet with
  <a href="el-variable:font-lock-builtin-face"><code class="highlighter-rouge">font-lock-builtin-face</code></a>. <a href="#fnref:6" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:7">
      <p>You can see the original comment in your Emacs by navigating to the
  definition of the variable <a href="el-variable:font-lock-comment-face"><code class="highlighter-rouge">font-lock-comment-face</code></a> with <kbd>M-x
  find-variable RET font-lock-comment-face</kbd>, or in your browser in
  Emacs’ Git web interface, at <a href="http://git.savannah.gnu.org/cgit/emacs.git/tree/lisp/font-lock.el?id=29c5e2cea22f909af7d33b290ca0eb23c5ad6c00#n292">font-lock.el, line 292</a>. <a href="#fnref:7" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>