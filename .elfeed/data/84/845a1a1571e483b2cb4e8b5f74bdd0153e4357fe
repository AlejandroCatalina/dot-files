<p>A while back I wrote about
<a href="http://swannodette.github.io/2015/02/23/hello-google-closure-modules/">Google Closure Modules</a>,
and talked a little bit about
<a href="http://en.wikipedia.org/wiki/Loop-invariant_code_motion">code motion</a>. A
few days ago I tried dog-fooding the discussed
<a href="http://clojurescript.org">ClojureScript</a> <code>:modules</code> functionality on
<a href="http://swannodette.github.io/mori/">Mori</a>, which exports
ClojureScript&#39;s standard library for JavaScript usage. To my surprise
attempting to split Mori into base and extras modules resulted in
a fairly large base (~36K gzipped) and surprisingly small extras (~9K
gzipped). Cross module code motion did not appear to be kicking in.</p>

<p>I examined
<a href="https://developers.google.com/closure/compiler/">Closure Compiler</a>,
specifically
<a href="https://github.com/google/closure-compiler/blob/d0605bdbf71771fa5954da9b927f9edddb8041bc/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java">CrossModuleCodeMotion.java</a>
looking for clues. This lead me to the intuitively named method
<a href="https://github.com/google/closure-compiler/blob/d0605bdbf71771fa5954da9b927f9edddb8041bc/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java#L433-L477">canMoveValue</a>. The
comment for this method reads:</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">canMoveValue</span><span class="o">(</span>
    <span class="n">ReferenceCollectingCallback</span> <span class="n">collector</span><span class="o">,</span> <span class="n">Scope</span> <span class="n">scope</span><span class="o">,</span> <span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// the value is only movable if it&#39;s</span>
  <span class="c1">// a) nothing,</span>
  <span class="c1">// b) a constant literal,</span>
  <span class="c1">// c) a function, or</span>
  <span class="c1">// d) an array/object literal of movable values.</span>
  <span class="c1">// e) a function stub generated by CrossModuleMethodMotion.</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">NodeUtil</span><span class="o">.</span><span class="na">isLiteralValue</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">||</span> 
      <span class="n">n</span><span class="o">.</span><span class="na">isFunction</span><span class="o">())</span> <span class="o">{</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div>
<p>Cross module code motion is very conservative, only obviously static
values will be moved and <code>c)</code> immediately jumped out at me as a
concern. For performance reasons multi-arity and variadic functions in
ClojureScript are actually implemented as functions with direct
methods attached as properties
(<a href="http://swannodette.github.io/2015/03/16/optimizing-clojurescript-function-invocation/">see my previous post</a>).
But that&#39;s our problem right there! Constructing multi-arity and
variadic function values requires an invoke and invokes aren&#39;t on the
list of things that Google Closure will move.</p>

<p>Simply put, large chunks of the ClojureScript standard library were
considered too dynamic to move by the Closure Compiler.</p>

<p>So after assessing a variety of ways to make the top-level more
static, I ended up deciding that top-level fns should be treated as a
special case and, to avoid further complications to the actual compiler,
to implement the change via customizing the <code>defn</code> macro. Being
able to do significant work at the macro level is definitely one of the big
perks of Lisp - it will probably come as no surprise to the Lisperati that the
ClojureScript macros file is bigger than the compiler file!</p>

<p>The actual changeset is pretty technical and of interest mostly to
experienced Clojure devs and ClojureScript compiler hackers, you can
<a href="https://github.com/clojure/clojurescript/commit/576fb6e054dd50ec458a3c9e4172a5a0002c7aea">see it here</a>.</p>

<p>After this change the end result for Mori is a much more reasonable
split, ~27K gzipped for the base module and ~18K gzipped for the
extras. We can likely further improve this, but already a significant
amount of ClojureScript source is now movable that previously wasn&#39;t.</p>

<p>For those of you unlucky souls that have to deal with JavaScript
build tools this was all the configuration required to get the
optimized Mori split:</p>
<div class="highlight"><pre><code class="language-clj" data-lang="clj"><span class="p">{</span><span class="ss">:cljs-base</span> <span class="p">{</span><span class="ss">:entries</span> <span class="o">#</span><span class="p">{</span><span class="nv">cljs.core</span> <span class="nv">mori</span><span class="p">}</span>
             <span class="ss">:output-to</span> <span class="s">&quot;release/build/mori.base.js&quot;</span><span class="p">}</span>
 <span class="ss">:mutable</span>   <span class="p">{</span><span class="ss">:entries</span> <span class="o">#</span><span class="p">{</span><span class="nv">mori.mutable</span><span class="p">}</span>
             <span class="ss">:output-to</span> <span class="s">&quot;release/build/mori.mutable.js&quot;</span><span class="p">}</span>
 <span class="ss">:extra</span>     <span class="p">{</span><span class="ss">:entries</span> <span class="o">#</span><span class="p">{</span><span class="nv">clojure.data</span> <span class="nv">cljs.reader</span> <span class="nv">clojure.set</span> <span class="nv">mori.extra</span><span class="p">}</span>
             <span class="ss">:output-to</span> <span class="s">&quot;release/build/mori.extra.js&quot;</span><span class="p">}}</span>
</code></pre></div>
<p>You can experiment with <code>:modules</code> and the enhanced code motion by
using the
<a href="https://github.com/clojure/clojurescript/releases/tag/r3178">0.0-3178</a>
pre-release.</p>
