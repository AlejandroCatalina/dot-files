I will once again plagiarize myself by transcribing a talk I gave.<br /><br />First: be warned!  I offer this gesture of respect to you — yes, you! — when I say that this is at least 20 minutes of reading.  This is long even for me.  If you're surfing reddit, gobbling up little information snacks, then it's best to think of this entry as being more like a big downer cow.  Unless you're <em>really</em> hungry, you should wait for it to be sliced into little bite-sized prion patties before consuming it.<br /><br />If you do read it, you'll see the CJD analogy is surprisingly apt.  I ramble even more than usual, and lose my train of thought, and the slides might as well be scenes from a David Lynch movie for all the relation they have to my actual talk.<br /><br />But once again I find myself astonished at how much I agree with myself, by and large.  Funny how that works.  And I made a few decent jokes here and there.  So I'm transcribing it.<br /><br />If you're impatient, and I wouldn't blame you a bit, the best part is probably "Static Typing's Paper Tigers".  That might be worth reading.  As for the rest... *shrug*  If you're really starved for content, you might find some of it entertaining.<br /><br /><b>The Setting</b><br /><br />I gave this talk at the <a href="http://code.google.com/events/io/">Google I/O Conference</a> in San Francisco a few weeks ago.  My talk was boringly titled "Server-Side JavaScript on the Java Virtual Machine", and there were initially only about 40 or 50 people in the room (out of a 2500-person conference) when I started the talk.<br /><br />Even though I personally thought the talk was pretty boring, people kept trickling in, and I estimate there were about 400 people stuffed in the room by the end.  It was standing-room only, and people were spilling out into the hall.  The conclusion?  The other talks must have been <em>really</em> boring.<br /><br />After my talk it became pretty clear to me that it should have been titled "Rhinos and Tigers", so that's its new name.  I've tried to make it flow well by splitting it into arbitrary sub-sections, whose titles aren't really part of the talk.  But otherwise it's pretty much a word-for-word transcription, except with most of the umms and aaaahs elided.  I've included the subset of the slides that seemed relevant; you can find the rest at the <a href="http://sites.google.com/site/io/server-side-javascript-on-the-java-virtual-machine">Google I/O site</a>.<br /><br />So enjoy!  Or not.  I've given you plenty of warnings.  You'll see!<br /><br /><b>Rhinos and Tigers</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQkA2vFdI/AAAAAAAAAGs/iNLcJLJGVms/s1600-h/rhino.002.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQkA2vFdI/AAAAAAAAAGs/iNLcJLJGVms/s320/rhino.002.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879248409597394" border="1" /></a><br /><br />Hello!  I'm Steve Yegge.  I work at Google.  I've been there about three years, and it's real nice.<br /><br />I'm going to be talking about server-side scripting in general, and talking a lot about <a href="http://www.mozilla.org/rhino">Mozilla Rhino</a> and the technology behind it.  I'm going to try to get through it in maybe 20-25 minutes, maybe 30 if I start ranting, at which point I'll open it up for questions.  I kind of want you guys to help drive how this goes.<br /><br />Make sense?  <em>(Ed:  Well, it made sense at the time.  Sigh.)</em><br /><br />All right, cool.  Let's get started.<br /><br />Sooo... I'm going to be talking about Server-Side JavaScript on the Java Virtual Machine.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQj9JinYI/AAAAAAAAAGk/YJzwSgwA194/s1600-h/rhino.003.jpg"><img style="cursor: pointer;" src="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQj9JinYI/AAAAAAAAAGk/YJzwSgwA194/s320/rhino.003.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879247414730114" border="1" /></a><br /><br />Yes.  We've got this big animal.  Rhino.<br /><br />So let's see... who here has used a JVM language before?  Oooh!  My god, lots of you, almost all of you.  Great!<br /><br />Well I'm going to be talking about Rhino in particular.  I'll be making reference to other JVM languages.  I want to kind of help you see how this fits into the landscape, why you might use it, why you might not use it.<br /><br />But for those of you who haven't used a JVM language, the Java Virtual Machine is sort of like .NET: you can run multiple languages on it.  You can write an interpreter in Java, or you can compile your language down to Java bytecode.  Or you can compile it down to your own bytecode; there are different ways to do it.<br /><br />But typically these languages are sort of drop-in replacements for Java.  Which means you can implement classes, you can implement interfaces, you can subclass things.  It gives you an alternate syntax and semantic layer on top of the libraries, and on top of the virtual machine.<br /><br />I'll assume that this makes sense... well, actually, I won't!<br /><br /><b>FOO Chaos</b><br /><br />There's this dude named <a href="http://en.wikipedia.org/wiki/Walter_Bright">Walter Bright</a>, who wrote the <a href="http://www.digitalmars.com/d">D programming language</a>, among many other things.  <em>(Raise hand)</em> Has anyone heard of Walter?  He's this really smart dude.  He wrote Symantec Cafe, and the game Empire [and Zortech C++].<br /><br />He told me the other day, [talking about] one of my blog rants, that he didn't agree with the point that I'd made that virtual machines are "obvious"<em></em>.  You know?  I mean, of course you use a virtual machine!<br /><br />But he's a compiler dude, and he says they're a sham, they're a farce, "I don't get it!"  And so I explained it [my viewpoint] to him, and he went: Ohhhhhhh.<br /><br />Virtual machines are great for language interoperability.  If everybody in the world used his language, then yeah, you probably wouldn't need a virtual machine.  You'd probably still want one eventually, because of the just-in-time compilers, and all the runtime information they can get.<br /><br />But by and large, we don't all use D.  In fact, we probably don't all use the same five languages in this room.  And so the VM, whether it's the CLR, or the Java VM, or Parrot, or whatever... it provides a way for us to interoperate.<br /><br />Now I'll tell ya — I was at Foo Camp last summer.  I've been wanting to tell this story...  I'm telling you guys; it's the coolest story.  And it's relevant here.  Heh.  Very relevant.<br /><br />So I was in this tent... you know what <a href="http://en.wikipedia.org/wiki/Foo_Camp">Foo Camp</a> is?  It's O'Reilly's, you know, <b>F</b>riends <b>O</b>f <b>O</b>'Reilly invite thing that they do each summer.  It's coming up in a couple of weeks.  And people give presentations; people show up and just wander into your [presentation] tent, and wander back out if they don't like it.<br /><br />So I was in this discussion at the very end of the last day, where the Apple <a href="http://llvm.org/">LLVM</a> guy Chris [Lattner] was hosting a talk on dynamic languages running on different VMs.  And there was the Smalltalk <a href="http://squeak.org/">Squeak</a> guy there, and there was <a href="http://headius.blogspot.com/">Charles Nutter</a> for <a href="http://jruby.codehaus.org/">JRuby</a> and representing the JVM. <a href="http://www.blogger.com/www.iunknown.com">John Lam</a> was there for <a href="http://www.ironruby.net/">IronRuby</a> and CLR, and there were the <a href="http://www.parrotcode.org/">Parrot</a> people.  I can't even remember them all, but the whole room was <em>packed</em> with the VM implementors of the VMs today, and people who are implementing languages on top of them.<br /><br />This was a <em>smart</em> group of people, and well-informed.  And you know, I was like a fly on the wall, thinking man, look at all [these brains].<br /><br />And Chris, well, he let everybody go around the room and talk about why their VM was the best.  And they were all right!  That's the weird thing: every single one of them was right.  Their VM was the best for what they wanted their VM to do.<br /><br />Like, Smalltalk [Squeak]'s VM was the best in the sense of being the purest, and it was the cleanest.  Whereas the Java one was the best because, you know, it has Java!  Everybody's was the best.  Parrot's was the best because it was vaporware.  Ha!  Ha, ha ha.  Sorry guys.<br /><br />So!  He [Chris] asked this really innocent question.  He goes, "You know, I don't really know much about this stuff..."<br /><br />Which is bad, you know.  When somebody says that to you at Foo Camp, it means they're settin' you up.<br /><br />He says, "So how do these languages talk to each other?"<br /><br />And the room just <em>erupted</em>!  It was chaos.  All these people are like, "Oh, it's easy!" And the rest of them are like "No, it's hard!"  And they're arguing, and arguing, and arguing.  They argued for an <em>hour</em>.<br /><br />And then they stood up, still arguing, and they kept talking about it, heading into the dinner tent. And they sat down, going at it for like three hours.<br /><br />It was <em>chaos.</em><br /><br />Because some people were saying, "Well, you know, if Ruby's gonna call Python, well, uh, you just call, right?  You just share the same stack, right?"<br /><br />And the others are like, "Well, what about different calling conventions?  What if they support optional vs. non-optional arguments?  What if they support default arguments?  What about the threading model?  What about the semantics of, you know, the <code>this</code> pointer?  What about all this <em>stuff?</em>"<br /><br />And they're like <em>(waving hands)</em> "Ooooh, we'll gloss over it, gloss over it, smooth it over."  And the reply is: "You <em>can't</em>.  This is fundamental.  These languages work differently!"<br /><br />And oh my god, it was really interesting.  And it was also very clear that it's ten years of research and implementation practice before they get this right.  Before you'll be able to have a stack of calls, where you're calling from library to function, library to function in different languages.<br /><br />So today, VMs are good for interoperability, but you've gotta use a bridge.  Whether it's JRuby, or Jython, or Rhino, they provide a set of APIs — you know about <a href="http://java.sun.com/javase/6/docs/api/javax/script/package-summary.html">javax.script</a>, right?  It's this new thing introduced to the JDK, where they try to formalize just a couple of APIs around how you call the scripting language from your language... you know, it's a sort of "reverse foreign-function interface".  And then how they call each other, maybe.<br /><br />But it's all done through... kind of like serialization.  You marshal up your parameters as an array of arguments, and it's a heavyweight call that goes over [to the script runtime] and comes back, and it's like... it's a pain!  You don't want that.  But today, that's kind of what we're stuck with.<br /><br />At least we have that, though, right?  I mean, try having Ruby call Python today, and they have different FFIs.  You can do it, but you definitely want the VM's help.<br /><br />So, Walter, that's why you need VMs.<br /><br /><b>Power to your users</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQknUP05I/AAAAAAAAAG0/_1-IqW5RS2I/s1600-h/rhino.004.jpg"><img style="cursor: pointer;" src="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQknUP05I/AAAAAAAAAG0/_1-IqW5RS2I/s320/rhino.004.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879258733925266" border="1" /></a><br /><br />So!  Yeah, there's a lot of stuff I could talk about.  I gave a practice of this talk to Mike Loukides, an editor at O'Reilly, and it completely changed what I wanted to talk about.<br /><br />I do want to talk about Rhino's technology; I want you to come away understanding it.  But more importantly, I want you guys to understand where this fits in this Google conference.  And where it fits in <em>your</em> plans, going forward.<br /><br />See, it's really interesting.  We all know, or at least most of us I think agree, that server-side computing is finally starting to make inroads onto the desktop.  Fat clients aren't so much the norm anymore.  You've got applications like Google Maps, GMail, Google Docs, those kinds of apps, that are doing "desktop quality" applications in the browser, with the server handling your storage.<br /><br />That's kind of one of the messages of this conference.  Everybody's doing it, right?  It's not just Google.  And it makes a certain amount of sense, so I'm not going to go into the reasons why you'd do that.  I'm assuming it's sort of a given.  <span style="color: rgb(106, 90, 205);"><em>(Editor's Note: you'd be amazed at how many emails I get from people who maintain it's a fad of some sort, one that's going away, which is why I bother to make this disclaimer.)</em></span><br /><br />The interesting thing is this: all applications... who was it who said "All apps will eventually grow to the point where they can read mail, and if they don't, they'll be replaced by ones that can"?  <em>(audience: "JWZ")</em> JWZ?  <a href="http://en.wikipedia.org/wiki/Jamie_Zawinski">Jamie Zawinski</a>.  Yeah.  It's a variant of somebody else's quote [Greg Kuperberg's], but...<br /><br />So it's true, right?  Apps grow.  If you like an app, you're gonna want to start doing more and more stuff in it.  If you like it a <em>lot</em>, like I like Emacs, heh... you know, you like your editor.  Everybody here is a programmer, right?  You all use development environments?  Do you ever find it kind of annoying that you have to switch from your IDE to your browser?  Why isn't the IDE the browser too?  Why aren't these unified?<br /><br />I mean, let's face it: I only run two apps.  Unless I need to run, like, <a href="http://www.omnigroup.com/applications/OmniGraffle/">OmniGraffle</a> or the <a type="amzn" asin="0735709246">Gimp</a>, or something to do a document, or <a href="http://www.apple.com/iwork/keynote/">Keynote</a> here to do the presentation — I just switched to Macs, so I'm learning all these names, but, this PowerPoint thing — most of the time, when I'm developing, I'm running shells, and I'm running Emacs, and I'm running a browser.  That's it!  So you kind of wish they'd be the same.<br /><br />Well, once they get big enough, your IDE and Emacs and the browser have this thing in common, which is that they are <em>scriptable</em>!<br /><br />That's the magic point at which your application becomes sort of <a href="http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html">alive</a>.  Right?  Because people can change it, if it doesn't work the way they like it.<br /><br /><a href="http://en.wikipedia.org/wiki/Greasemonkey">GreaseMonkey</a>!  Perfect example.  You don't like our web page that we give you?  Write a GreaseMonkey script and change it all around, right?  That's cool!  Scripting is really important.<br /><br />I mean, Emacs, it stands for "Editor Macros", and it started off as a really thin engine, and the whole editor was written in scripts.  And now it's huge.  It has a million lines or so of Emacs-Lisp code floating around.<br /><br />So it's weird... you go through this transformation, where your scripting languages are originally for, well, scripting.  And it eventually grows into application level/scale development.  OK?<br /><br />Now we all see this happening in clients.  Excel, for instance, is scriptable.  And the reason that Excel is so powerful, I mean the reason that you can go to the bookstore and get a book that's <a type="amzn" asin="0321262506">this thick</a> on Excel, and scientific computing people use it, whatever, is that it has a very very powerful scripting engine.<br /><br />In fact, all of Microsoft Office has it.  Right?  You can fire up Ruby or Python or Perl, and you can actually control, though the COM interface, you can actually <a href="http://steve.yegge.googlepages.com/scripting-windows-apps">tell IE to open a document</a> and scroll to a certain point in it.  Or you can open up Microsoft Word and actually... I mean, if you want to do the work, you could actually get to where you're typing into your Perl console and it's showing up over in Word.<br /><br />Server-side computing has to get there.  It's <em>gonna</em> get there.<br /><br />But how many server-side apps are user scriptable today?  Precious few.  Google has a couple, you know, like our <a href="http://en.wikipedia.org/wiki/JotSpot">JotSpot acquisition</a>, which is [scriptable] in Rhino...<br /><br />So we're talking about something that's kind of new.  I mean, we can all see it coming!  But it's still kind of new, the idea, right?  Why?<br /><br />Because this is scary hard, from a security perspective.  Heh.  You're going to run code on <em>my</em> servers?  Uh... OK...<br /><br />I mean, Yahoo! Store, you know, Paul Graham's <a href="http://en.wikipedia.org/wiki/Viaweb">Viaweb</a> that <a href="http://www.paulgraham.com/avg.html">went on to become Yahoo! Store.</a> People have done it, right?<br /><br />I wrote a <a href="http://www.cabochon.com/">game</a> that was really cool.  <a href="http://www.cabochon.com/wiz/code_examples">Scriptable</a>!  I mean, high school kids were teaching themselves to program so they could write areas and monsters and spells and quests for this game that I wrote, which was written in <a href="http://www.cabochon.com/api/index.html">Java</a> and scriptable in Jython.<br /><br />It's a big deal!  I mean, people want to be able to write these apps.<br /><br />However, I had to live with the fact that I didn't personally have enough bandwidth to come up with a decent security model to keep them from...  it's a trust-based security model in my game.  They write a script, they could erase my hard disk, right?  So I've got to be very careful, and recognize that I can only let certain people that I trust do it.  And that I've got to be prepared for really big disasters.<br /><br />Because also there's denial-of-service.  It's inadvertent: oh, their script is taking up all the bandwidth [or CPU or memory] on my server, and everybody else in the game is paralyzed.  Right?  I mean, how do you deal with it?<br /><br />You've got to deal with user [i.e., programmer] throttling:  memory usage, the database or datastore usage, like Amazon's computing cloud, you know, they have a lot of this stuff in place.  But usually it's pretty coarse-grained when it gets started, right?  You get a box, and a certain amount of disk storage, and you get the whole CPU, because how are you gonna allocate CPUs out to people when the languages themselves that are being used for scripting don't support that?  <span style="color:#6a5acd;"><em>(Editor's Note: obviously you can just use process scheduling, but I'm talking more about multithreaded processes like my game, or Second Life, where many users may be scripting within the same processes.  It makes things harder.)</em></span><br /><br />We're getting there; it's happening.  But it's new.  And it's hard.  Because you don't want people to be able to go and get access to your company's proprietary code or resources and wreak havoc.  You just want to host their computing.<br /><br />So when you decide you're going to take your server-side application, with its beautiful Ajax app talking to the server, and now you want open it up: to add extensibility for your end users &mdash; they're not just scripting the client; there's scripting happening on the server that's theirs &mdash; you have to make a decision!<br /><br />Namely, what language are you going to give them?<br /><br />We have... see, unfortunately it's hard for me to talk about Google products, because all I know are their internal code names, and not their launch names.  I can never remember them.  But we have...  something like that.  Heh.  Called... Prometheus, I think?  Uh, wha... what is it?<br /><br /><em>(audience member: Google App Engine)</em> Ahem, the <a href="http://code.google.com/appengine/">Google App Engine</a>, of course!  Yes.  The Google App Engine.  Ahem.  Yes.  <em>(me: embarrassed)</em><br /><br />And I think it's... Python.  Right now.  But of course they want to open it up, because, it's like, you don't really want to force people to switch editors, unless you want a real fight on your hands.  You kinda don't really want to force people to switch languages either, right?  People want to use whatever they're comfortable with.<br /><br />So again, you wind up with this hosted environment, where you're supporting multiple languages; which one do you pick [first]?  They picked Python.  You can pick [anything], but you've got these problems to deal with.  And I'm going to argue today that Rhino is actually a really good choice for this particular problem space.<br /><br />OK, we've got people pooling up in the back here.  Is it time to invite them in?  Come on in, sit down, there's space!  All right, cool.  Yeah.  Welcome!<br /><br />So yeah.  That's what I'm talking about today.  Do you guys understand the perspective now, the context?  I'm talking about server-side scripting, that either you do yourself inside your company, because you feel like you've got some logic that needs to be kind of "glue" logic — "scripting" — or, more importantly, you're opening it up to your users.  Which means you need to sandbox it, and you need to meter it and throttle it.<br /><br /><b>Advantages of scripting on the JVM</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQlCi8uCI/AAAAAAAAAG8/gsEX2Vueb6w/s1600-h/rhino.005.jpg"><img style="cursor: pointer;" src="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQlCi8uCI/AAAAAAAAAG8/gsEX2Vueb6w/s320/rhino.005.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879266043344930" border="1" /></a><br /><br />All right.  Yeah.  So this is a JVM language.  A JVM language can share the Java libraries, and the Java Virtual Machine.  It's really cool, right?  And really powerful.<br /><br />Right off the bat, these JVM implementations of other languages, like JRuby vs. Ruby, Jython vs. Python, right?  They get all these free benefits, that may not necessarily exist in the C runtimes for these languages.<br /><br />Example?  Java has a really good garbage collector these days.  A <a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Generational_GC_.28aka_Ephemeral_GC.29">generational garbage collector</a> that's becoming an incremental [and/or concurrent] generational garbage collector... I mean, it's good!  Whereas for a lot of these [C-based] languages, they use mark-and-sweep, reference-counting...<br /><br />Another one is native threads.  It's veeery nice to have native threads, and also have well-defined semantics for the threads and how they interact with the memory model.  I mean, a lot of these [non-JVM] languages are like, "Well, we have threads, but you probably... don't want to use them."  Because you're kind of on your own.<br /><br />So what happens is people use process-switching; it's the share-nothing model.  And that's great too, for certain situations.  Provided you've got good engineering library support around it, like the <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/package-summary.html">java.util</a> concurrency libraries.  They can help you design something without having to do a formal proof around it to get it to work.<br /><br />That helps a lot in multicore.  It helps!  JavaScript has no [language-level] threads, because Brendan Eich says "<a href="http://weblogs.mozillazine.org/roadmap/archives/2007/02/threads_suck.html">over his dead body</a>".  I totally understand where he's coming from on this, right?  There's certainly the "promise" of better concurrency out there.  Erlang, you know, and maybe <a href="http://en.wikipedia.org/wiki/Software_transactional_memory">STM</a>...<br /><br />But hey man, today?  I mean, right now?  You want to write something with high throughput, and you've got a lot of I/O to do, and it's parallelizable?  And you want to get a lot of throughput on one box, because it's got multiple cores?<br /><br /><em>(shrugging)</em> Well, threads get the job done.  So if you've got it in your so-called "scripting language", it's a big win.<br /><br />We've got garbage collection, threads... and asynchronous I/O, right?  When Java first came out there was the whole "one thread per socket" model [actually, two], which meant that you couldn't write a webserver that could handle ten thousand concurrent requests.  It didn't matter how much memory or CPU your box had.  Anyone here ever tried to fire up 10,000 threads on one box?<br /><br />Yeah...  yeah.  What happens is, the scheduler and task-switching resources for managing the threads swamp your machine.  So eventually Java wrote a <a type="amzn" asin="=&quot;0596002882&quot;">wrapper</a> around the Unix or Windows or whatever native interfaces so you could get super-high throughput.<br /><br />So all of the sudden, by sticking something on the JVM...  Sure, you initially get a bit of a hit in performance.  When these people first port a language to the Java Virtual Machine, it's usually about twice as slow, right?  BUT, it's got async I/O, and it's got [native] threads, and it's got better non-pausing (by and large) garbage collection.  And from there, they can make it smarter.<br /><br />But they've also got the JIT.  I don't know, I mean, did anybody here...  I gave a <a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html">talk on dynamic languages</a> recently at Stanford, but I don't want to rehash that if you guys already know about that.<br /><br />Basically I argued in that talk — successfully at Stanford, so I think that was... something — that for <a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time compilers</a>, it's becoming pretty clear, they have a lot better access, a lot better data at runtime about how you're actually using your program right now than the compiler ever had.<br /><br />So the JITs can do all kinds of inlining and optimizations that you just can't do in a compiler.  And what that means is that everybody running on this VM gets to benefit from the JIT.<br /><br />So there are lots of advantages to these JVM languages.  Or .NET, if you happen to be using Microsoft stuff.  It's a good model.<br /><br /><b>But why Rhino?</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQlhEpN8I/AAAAAAAAAHE/_z3Yu9KgAms/s1600-h/rhino.006.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQlhEpN8I/AAAAAAAAAHE/_z3Yu9KgAms/s320/rhino.006.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879274237736898" border="1" /></a><br /><br />So why Rhiiiiino?  Why JavaScript?<br /><br /><em>(loudly)</em> Who here thinks JavaScript is kind of icky?  Come on, come on, be honest.  Yeah, there we go, a couple of people.  Yeah.<br /><br />Yeahhhh... and you know what?  It is!  Right?  Because, well, because of vendor implementation issues.  That's one [reason].  Also, Brendan was kind of forced to rush it out the door.  You guys know... back at Netscape, when they built JavaScript, it was called, um, LiveScript?<br /><br />And Brendan was building <a href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> for the browser.  Scheme!<br /><br />Everyone in here who knows Scheme, raise your hand.  <em>(Many people, at least fifty, raise their hands.)</em><br /><br />Holy... smokes!  A lot more than I would've guessed.  Wow.<br /><br />OK, well, as it happens, you guys are not "representative". <em>(laughter)</em><br /><br />And so, Netscape kinda looked at it, and said: "Yeah, well, we did say Scheme, but, uh, there's this Java thing, this giant marketing thing, and we want to be involved with it."  And some back-door deals happened, and then they came to Brendan and said: "Make it look like Java."<br /><br />So now it's Scheme with Java syntax, right?  So he had to pull a lot of all-nighters for a couple of weeks, and he came up with JavaScript.<br /><br />So, you know, it's got some flaws.  Some of which make you want to go scrape your teeth on the sidewalk because it's less painful.  So it's true, but what language doesn't have some flaws?<br /><br />The interesting thing about Rhino, which is an implementation of JavaScript in Java, is that there's only one language.  You don't have to worry about vendor-implementation or cross-platform problems because... it's just Rhino.  So right out of the starting gate, that's a win.<br /><br />Plus, Rhino gives you the ability to work around some of the problems.  A classic one is the problem in JavaScript where you can't define non-enumerable properties.  Right?  You know how you can go <code>for (i in foo) ...</code>, and it'll enumerate the keys of your object as if it were a hashtable.<br /><br />Nice feature, right?  And you can add properties to objects; you can go to <code>Object.prototype</code>, which is the root object of the whole system, and add your own function(s) there.  But what happens is, you've added a function that's now enumerable in everybody's arrays, and everybody's data structures, so their <code>for..in</code> loops break.<br /><br />Which means that fundamentally you can't install a library that's completely seamless and emulates Ruby or Python or some other really expressive set of library functions.  Like, you want your <code>map</code> and <code>collect</code>, and your <code>String.reverse</code>, and...  you know what I mean?<br /><br />You can't do it in browser JavaScript, so people wind up going different routes.  They either do what <a href="http://prototypejs.org/">Prototype</a> does, and just install it, and you're screwed if you use <code>for..in</code>, but you don't use <code>for..in</code>, right?<br /><br />Or they use functions.  They don't use object-oriented programming.  And you know, functional programming is great and everything, but OOP, as we've discovered in programming in the large, is a nice organizational tool.  Putting the function or method together with the thing that it's operating on is a nice way of organizing things.<br /><br />So it's kind of unfortunate when you have to use functions, because if you have to say, you know, <code>HTMLElement.getChildren.whatever</code>, it gets inverted with functions: <code>whatever(getChildren(HTMLElement))</code>.  You have to call from the innermost one to the outermost... it's "backwards", right?<br /><br />Rhino winds up getting around that problem completely.  We did, anyway, internally.  Because it's written in Java.  So you can call the <a href="http://www.mozilla.org/rhino/apidocs/">Rhino interface</a>.  You can call Parser, or the interpreter, or the runtime; you can do whatever you want.<br /><br />So I wrote this little <code>defineProperty</code> function, that's like five lines of code.  It calls into the script runtime <a href="http://www.mozilla.org/rhino/apidocs/org/mozilla/javascript/ScriptableObject.html">Java class that implements JavaScript objects</a>, which has a <a href="http://www.mozilla.org/rhino/apidocs/org/mozilla/javascript/ScriptableObject.html#DONTENUM">non-enumerable</a> <code><a href="http://www.mozilla.org/rhino/apidocs/org/mozilla/javascript/ScriptableObject.html#defineProperty%28java.lang.String,%20java.lang.Object,%20int%29">defineProperty</a></code>.<br /><br />JavaScript has non-enumerable properties; it just doesn't let you add your own.  It's just a language flaw, right?<br /><br />That [<code>defineBuiltin</code> function] enabled us, in the project I'm going to be talking about a little bit later here, to implement all of Ruby and Python's runtime — all the functions we liked — in [server-side] JavaScript, in a non-intrusive way.  We were also able to implement a class system, and all this other stuff.<br /><br />So Rhino is <em>not</em> browser JavaScript.<br /><br />Man, we've got more people pooling up at the entrances.  You guys are welcome to come in, squeeze in and sit down... come on in... welcome.  There's still space.  Especially up here kinda in the front, in the middle, where nobody wants to sit.  But trust me, it's better there.<br /><br />So yeah.  Rhino's history:  it's like ten years old.  Or more?  More than ten years, maybe.  It started inside Netscape, side by side with <a href="http://www.mozilla.org/js/spidermonkey/">SpiderMonkey</a>.  A lot of people have been hacking on it.  Rhino's pretty robust.<br /><br /><b>Rhino at the shootout</b><br /><br />I have a question for ya.  I did this "JVM shootout" like three and a half years ago.  I was kind of tired of using Java for scripting, and I wanted to look at all the JVM languages.  So I did this game.  You know about the game <a href="http://en.wikipedia.org/wiki/Sokoban">Sokoban</a>?  I would have done Sudoku if the craze had hit then.  It's a little dude who pushes these blocks around these mazes?<br /><br />Well, I reimplemented this thing, which is about, you know, six or seven hundred lines of Java code.  It had a [user] interface, and a little search algorithm that had him chase your mouse.  It was just big enough of an application that I could reimplement it in like 10 different languages, and actually compare how it was speed-wise, how to use them [the languages], how well they interoperated with Java... it was an actual apples-to-apples comparison.<br /><br />Most of them really, really, REALLY stank.  It was baaaad.  I mean, there are like <a href="http://www.is-research.de/info/vmlanguages/">250 JVM languages</a> out there, but most of them are just complete toys.  But there were ten or so that were actually pretty good.  You could do anything in them, and they had decent performance, and they were good, right?<br /><br />And it [the shootout] kind of petered out, because it started looking like Rhino-JavaScript was going to win.  I had this sort of <a href="http://en.wikipedia.org/wiki/Decision-matrix_method">solution selection matrix</a> of criteria where... it was kind of a heuristic function where I weighted all these terms, right?  Just to kind of get a feel for which one [was best].<br /><br />And I wanted JRuby to win.  You should never go into these comparisons wanting one of them to win, because, you know, you're either going to bias it or you're gonna be disappointed.  JRuby at the time was really slow.  It's much faster now, and everything, but at the time, it was so new.<br /><br />Jython was good, but it wasn't fast enough, and the author of Jython had gone off to greener pastures.<br /><br />Rhino!  Rhino had good tools, and it had good performance, and it was... JavaScript!  Eeeeww!<br /><br />So I never even really... I published it, but I didn't leave it up.  I'm actually going to bring it back up again soon; I'm going to update it and do a couple of new languages.  Because I find this an eternally fascinating question, which is: what is the <a href="http://steve-yegge.blogspot.com/2007/02/next-big-language.html">next big language</a>, especially on the JVM, going to be?<br /><br /><b>Domain-specific languages</b><br /><br />Java will always have a place.  But I think there are domains, like Java Swing, you know?  The Java GUI stuff?  Java's really not very good for that.  We've kind of figured out that Object-Oriented Programming doesn't work that well for UIs.  You want it to be declarative.  HTML showed that you want a dialog, with a title bar, and a body, and it <em>nests</em>, to match the [UI] tree.<br /><br />That works really well.  It's succinct.  Even in HTML it's succinct, right?  Whereas with a [Java-style] object-oriented language, you've got to say, you know, <code>createContainer()</code>, <code>addChild()</code>, <code>addChild()</code>, <code>addChild()</code>, 'til the cows come home.  And it doesn't <em>look</em> anything like... you can't pattern-match it and say "ah yes!  this looks just like my UI!"<br /><br />So people write these wrappers around Swing.  Like there's <a href="http://commons.apache.org/jelly/">Apache Jelly</a>, which wound up with this XML framework to do Swing programming, that was 30% less verbose than Java.<br /><br />What are the odds that XML's going to wind up being less verbose than <em>anything?</em>  <em>(loud laughter)</em>  Really!  I mean, I was shocked.  30% less verbose.  And I looked at it, too.  They weren't cheating.  I mean, they did the best Swing implementation in Java that they could, but Jelly was better.<br /><br />So there are domains for which Java is just not appropriate.  But you still maybe want to use a VM for all the reasons that I outlined earlier.<br /><br />So yeah!  There's room for these other languages.  But which one?  All of them?  Are they going to solve the problem I brought up from Foo Camp earlier?  To where it doesn't matter which language you're using; they can call each other, and [mix however you like?]<br /><br />I mean, how's your editor going to feel about that?  How's your team member going to feel about it?  A lot of people don't like learning new languages.<br /><br />Who here doesn't like learning new languages?  Come on, be honest... <em>(A few people raise hands)</em>  Yeah!  New languages.  No fun!<br /><br />It's actually kind of... you should try it.  <em>(laughter)</em>  You know?  It is.  It's a good idea.<br /><br />There's this dude — has everyone heard of <a type="amzn" asin="0262560992">The Little Schemer</a>?  The Little Schemer, <a type="amzn" asin="026256100X">The Seasoned Schemer</a>, <a type="amzn" asin="0262562146">The Reasoned Schemer</a>?  Cool books, right?  Teach you functional programming in this really bizarre format that hooks you in.<br /><br /><a href="http://en.wikipedia.org/wiki/Daniel_P._Friedman">Dan Friedman</a>, the guy who [was] one of the collaborators on those books &mdash; I was reading an <a href="http://www.cs.indiana.edu/hyplan/dfried/mex.pdf">article he wrote</a>.  Early in his career he realized that languages are fundamental to computer science and to engineering; they're really important.  And he wanted to be able to learn a new language every quarter.<br /><br />And after he did that for a while, he said, you know what?  I want to learn a new language every <em>week</em>.  OK?  And you can actually get to the point where you can do this.  Now it probably takes 2-3 months before you're actually as comfortable with the new language as you were with your favorite old one.  This happened to me with JavaScript; I was freaking out for the first couple of months, thinking "this is <a href="http://steve-yegge.blogspot.com/2007/06/rhino-on-rails.html"><em>never</em> gonna work</a>".<br /><br />But eventually you get over the hump, and you're like <em>(relieved sigh)</em> "aaaah, yes."  Right?  You learn how to work around the problems.  It's just like learning Java or whatever your first language happened to be.  You've got to learn your way around all these problems, and you've gotta learn how things work, and how the libraries are laid out.  And all of the sudden it becomes like breathing.<br /><br />So Dan Friedman, after he said he was learning a language a week, I thought, "wow, that's pretty macho."  But he said, nah, that wasn't good enough:  he wanted to be able to <em>implement</em> a language a week.  And he got pretty serious about it.  Spent years researching how to do this effectively.  <em>(Well, now I'm just speculating &ndash; Ed.)</em><br /><br />This is where I'd love to see engineers today.  Knowing languages will make you a better programmer.  It will!  It will even if you're not using them.  Just write a little application in it, and it opens your mind.  [Each new one] opens your mind.  And now suddenly you know the superset of all the languages out there.  So it's not scary to learn new ones.<br /><br />And you can also recognize situations where a <em>language</em> is actually the right tool for the job.  Not a library, not a framework, not some new object or some new interface.  A language!<br /><br />Case in point?  <a type="amzn" asin="0596528124">Regular expressions</a>.  <em>(raise hand)</em> Who likes to write their own giant deterministic finite automata to do string matching?  Heh.  It's weird — nobody raised their hand.<br /><br />Who likes to do lots and lots of manual DOM manipulations, as opposed to, say, <a type="amzn" asin="0596002912">XPath</a>?  XPath is a language, right?  DOM manipulations, you know... it depends, but usually, no:  not if you can get away with using a language for it.<br /><br />I could talk for hours about that, so I'm not going to.  But, you know... it's good to learn new languages.  So I'm gonna teach you JavaScript today.  I'm gonna dive in.  So let's go!<br /><br /><b>The right way to do unit testing</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQxaOLwAI/AAAAAAAAAHM/TxmH0v-culY/s1600-h/rhino.007.jpg"><img style="cursor: pointer;" src="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQxaOLwAI/AAAAAAAAAHM/TxmH0v-culY/s320/rhino.007.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879478557130754" border="1" /></a><br /><br />Oh yeah.  So unit testing.  I mean, like, all the other stuff on this slide is like "blah blah blah", but then Unit Testing [in Rhino] — this was a real surprise to me.<br /><br />I write a lot of Java code day to day, [out of the] probably five different languages I code in regularly.  And unit testing was always a chore.  Unit testing is a chore.<br /><br />I mean, come ON.  Unit testing's a chore, right?  <em>(raise hand)</em> Who here thinks unit tests are just a poor man's static type system?  Eh?  <em>(some laughter)</em>  Yeah!<br /><br />Well, not really, since you have to write unit tests for them [the static languages] too.  <em>(more laughter)</em><br /><br />You need to write unit tests, and unfortunately in Java it's <b>very painful</b>.  I'm speaking into the mic now, so that everybody can hear.  Unit testing in Java is painful!<br /><br />It's <em>so</em> painful that people, the Java... community, the Java world, has evolved <em>around</em> it.  OK?  They've said:  "Don't use constructors.  Constructors are baaaaad."<br /><br /><em>(pointed pause)</em>  I mean... what!?  <em>(laughter)</em><br /><br />I mean, like, if you program in Ruby, say, you know that you can actually change the way the metaclass produces objects.  So if you want it to be a singleton, or you want it to meet certain... you want it to be a Mock object, you just replace the <code>new</code> function on the fly, and you've got yourself a Mock constructor, right?<br /><br />But Java's set in stone!  So they use factories, which leads to this proliferation of classes.  And you have to use a "Dependency Injection Framework" to decouple things, right?<br /><br />And it's just, like, <em>(panting)</em>...  We were doing business logic early on in Java.  When Java came out, it was like:  "Ooooh, it's a lot easier to write C code", basically, or C++.  Rather than focusing on your memory allocation strategy, or which of your company's six conflicting <code>string</code> classes you're gonna use, you get to focus on "business logic".<br /><br />But unfortunately that only took you so far.  Now you're focusing on Mock object frameworks.  It [Java] only took you a little farther.<br /><br />Now I <em>swear</em>, man, doing Mock objects in Rhino is so easy!  It's easier, even, than in JRuby or in Jython, because JavaScript has <a href="http://www.json.org/">JSON</a>.  I didn't even know, like, the name of it when I started doing this, right?  But JSON... I've gotta show you guys this.  This is so cool.  <em>(flipping through slides)</em><br /><br />Yeah, tools, blah blah blah.  We'll come back to it.  Oh, it's way down in here.  Urrggh.  Come on... here's one!<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQ0HS8L4I/AAAAAAAAAHs/ewGDWznPYL4/s1600-h/rhino.011.jpg"><img style="cursor: pointer;" src="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQ0HS8L4I/AAAAAAAAAHs/ewGDWznPYL4/s320/rhino.011.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879525016416130" border="1" /></a><br /><br />OK.  Down on the bottom we've got some code here.  Actually on the top, too.  So I do a <code>new Thread</code> with a <code>new Runnable</code>, and, uh... it sure looks a lot like Java code, huh?  This is one advantage of JavaScript, actually.  Java...Script, right?  Ten years later it's finally becoming the scripting language for Java?<br /><br />So that syntax <em>(with an obj literal following <code>new Runnable()</code>)</em> is a little weird, but there's another one here that says:<br /><br /><pre>js&gt; obj = {run: function() { print('hi') }}</pre><br /><br />So I've declared an object literal, using "JSON style".  Now JSON doesn't let you do — does JSON let you do functions?  Probably not, right?  But I mean, fundamentally you're doing this declarative property-value list, right?<br /><br />And so what I've got is this anonymous thing that has a named "run" property whose value is a function!  That prints "hi".  And now I can create a new <code>Thread</code>, with a new <code>Runnable</code> that wraps it, and what effectively I've done is I've used that thing as the <code>Runnable</code> interface [implementation], which expects a function called "run" that takes no arguments and does whatever the thread's supposed to do.<br /><br />This is how you do mock objects!<br /><br />I have this huuuge legacy system, right?  With hundreds of static methods.  Static methods are also bad these days, right?  Noooo static methods.  'Cuz they're not mockable.  Right?  Java has changed Java.  Because Java's not unit-testable.  So now you can't just go to the store and [buy a book and] learn Java.  You have to learn all these... fashions.  You have to learn what's in vogue.<br /><br />Subclassing!  <i>Not</i> in vogue right now.  You talk about subclassing, and people are like "NNnnnnnooooo, you should use manual delegation even though it's really hard and cumbersome and awkward."<br /><br />And you're like, "but I just want to change this one method, and plus it's built into the language, and there's syntax for it, and it's kind of well-understood..."  And they just say "NO!"<br /><br />It's out of favor.  For similar reasons.  Oh my god...<br /><br />And I'm telling ya:  the reason unit testing is easy, is, fundamentally, the way you develop in a dynamic language is <em>different</em> from the way you develop in a static language:  C++, Java... OCaml, Scala, whatever.  Your favorite static language.<br /><br />To a large extent, especially in C++ and Java, the way you develop is:<br /><ol><li>you write the code</li><li>you compile the code</li><li>you load the code</li><li>you run the code</li><li>it doesn't work</li><li>you back up</li><li>you change it again</li></ol><br />So it's this batch cycle, right?  1950s.  Submit your punch cards, please.<br /><br />In a dynamic language — and this is clearest when you're writing in Emacs Lisp [because of the <code>*scratch*</code> buffer] — but it's somewhat clear when you're developing in a console, in Python or Ruby, Perl, Lua, whatever, you write an expression, and you give it some mock data.<br /><br />You're writing a function, you're building it on the fly.  And when it works [for that mock data], you're like, "Oh yeah, it works!"  You don't run it through a compiler.  You copy it and paste it into your unit test suite.  That's one unit test, right?  And you copy it into your code, ok, this is your function.<br /><br />So you're actually proving to yourself that the thing works by construction.  Proooof by construction.<br /><br />Obviously you still need your unit tests <em>(er, I meant integration tests – Ed.)</em>, because there's going to be higher-order semantics, you know, calling conventions between classes and methods...<br /><br />Whew!  This room is really filling up.  Um, is there anything we can do to help here, guys in the back?  <em>(Tech guy says something inaudible in the video)</em>  Yeah, please!  There're more seats here.  I just want to... I don't want to get to where people can't even make it into the room.<br /><br />Yeah, so unit testing.  I know you guys all hate unit testing.  So did I.  Or you say, "I looooove unit testing," but then, you know, your test coverage is still sitting at like 80%.<br /><br />I'm telling you, man, this is a huge, huge thing.  It changes the way you do your development.<br /><br /><b>Rhino's not Ruby</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRRQ2jUfAI/AAAAAAAAAIk/eEdQJwjc0lA/s1600-h/rhino.018.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRRQ2jUfAI/AAAAAAAAAIk/eEdQJwjc0lA/s320/rhino.018.jpg" alt="" id="BLOGGER_PHOTO_ID_5211880018737921026" border="1" /></a><br /><br />And oh, yeah... I'm going to be talking shortly here about <a href="http://steve-yegge.blogspot.com/2007/06/rhino-on-rails.html">Rhino on Rails</a>, which is this thing that I did... it's not Rhino on Rails, actually.  It's actually, <em>I</em> called it "Rhino's not Ruby".  Because I got kinda burned at Google for using Ruby.  Yeah.  Uh, for good reasons, good reasons.  But they were like: "No."<br /><br />And so of <em>course</em> I called it "Rhino's not Ruby":  RnR.  Because people know JavaScript; they're kinda comfortable with JavaScript, so they were OK with it.  So I had to port Rails; it was kind of a lot of work, but, you know, well it works!  We're using it here internally; it's nice.  I mean, I actually know it's nice, because six months went by and I didn't look at it for those six months.  And for this recent project, I picked it up, and I was, like, is this gonna be gross?<br /><br />But actually, it's really pretty nice.  Because you've got all the Java libraries, and all the integration with Google stuff.  It's cool.  I'll try to open-source it this year, if I forget to say that later on.<br /><br />Anyway, I was writing unit tests for this thing, and... uh... <em>(I completely blow my stack.  Who am I?  Where am I?)</em><br /><br />Have I lost where I am on the slides? <em>(Duh.)</em><br /><br />I've diverged from the slides.  I'll come back to RnR shortly.  Basically, I got unit-testing religion.  That's the end of that sort of stack.<br /><br />If you can do it easily, and you don't have to rewrite your application to be unit-testable?  Man.  That's a big difference.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/__0laCHgF5uc/SFRQy7mj4LI/AAAAAAAAAHc/XF1MAOiqvhk/s1600-h/rhino.009.jpg"><img style="cursor: pointer;" src="http://1.bp.blogspot.com/__0laCHgF5uc/SFRQy7mj4LI/AAAAAAAAAHc/XF1MAOiqvhk/s320/rhino.009.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879504697614514" border="1" /></a><br /><br />So why would you <em>not</em> use Rhino for server-side scripting?<br /><br />Well, it's not super-duper fast right now.  It's on the order of about twice as slow as Java, depending on what you're doing.  So if it really has to be super, super fast — use C++!  Right?  Naaaah, you can use Java.  Like I was saying the other day [at Stanford], it's widely admitted inside of Google — there's this whole discussion, is Java as fast as C++, right?  And Google Java developers definitely admit that it's as fast as C++.  The C++ people, well... yeah. <em>(sigh)</em><br /><br />Let's see... if you're writing a library, then Rhino's actually not so good right now.  There is no standard library interface for scripting languages.  We haven't got there yet.  It's all, it's all related to what I told you about before, you know the calling interop.  A lot of these [languages] have their own package systems:  their own <code>import</code>, their own <code>require</code>, right?  So if you're gonna write a library, you should probably still write it in Java.  Maybe.<br /><br />If you're doing a framework, where you're defining how things are called:  whether we're calling you, or you're calling us, then it's OK.<br /><br />And if you really <em>hate</em> JavaScript, then that's, you know, that's fine...  But keep in mind, again, that you may be providing something for your end-users.  If you go out to a high school and you survey people, and you ask, "So what language are you learning?  How are you teaching yourself programming?"  It's a sure bet that a lot of them are doing Ajax stuff.  Right?  A lot of them are doing JavaScript.<br /><br />If you want to make your end-users happy, and you want to immediately capture a very big user base, then no matter how you detest JavaScript (and again, Rhino-JavaScript's really not as bad as browser JavaScript, it's much better), your users probably will prefer it.  It's something to keep in mind.<br /><br />All right.<br /><br /><b>Static Typing's Paper Tigers</b><br /><br />And then we've got <a href="http://www.scala-lang.org/">Scala</a>.  I've gotta mention Scala.  Who here knows... you've heard of Scala?  Yeah?  <em>(a few hands go up)</em> Mmmmm, yeah, getting there... looks like some people, OK.<br /><br />Scala is a very strongly typed language for the JVM.  It's from researchers in Switzerland; they're professors.  It's from sort of the same school of thought that static typing has evolved with over the last fifteen years in academia:  Haskell, SML, Caml, these sorts of <a href="http://en.wikipedia.org/wiki/Hindley-Milner">H-M</a> functional languages.<br /><br />And Scala's interesting because it actually takes a functional static type system and it layers... it merges it with Java's object-oriented type system, to produce....  Frankenstein's Monster.<br /><br />I've got the <a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf">language spec</a> here in my backpack.  Oh, my god...  I mean, like, because it's getting a little bit of momentum, right?  So I figure I've got to speak from a position of sort of knowledge, not ignorance, when I'm dissing it.  (Heh heh.)<br /><br />And so <em>before</em>, I was like: "Oh yeah, Scala!  Strongly typed.  Could be very cool, very expressive!"<br /><br />The... the the the... the language spec... oh, my god.  I've gotta blog about this.  It's, like, ninety percent [about the type system].  It's the biggest type system you've <em>ever</em> seen in your life, by 5x.  Not by an order of magnitude, but man!  There are type types, and type type types; there's complexity...<br /><br />They have this concept called <code>complexity complexity&lt;T&gt;</code>  Meaning it's not just complexity; it's not just complexity-complexity:  it's <em>parameterized</em> complexity-complexity.  <em>(mild laughter)</em>  OK?  Whoo!  I mean, this thing has types on its types on its types.  It's <em>gnarly</em>.<br /><br />I've got this Ph.D. languages intern whose a big Haskell fan, and [surprisingly] a big Scheme fan, and an ML fan. [But especially Haskell.]  He knows functional programming, he knows type systems.  I mean, he's an expert.<br /><br />He looked at Scala yesterday, and he told me:  "I'm finding this rather intimidating."<br /><br />I'm like, "THAT sounds like it's gonna take off!"  <em>(loud laughter)</em>  Oh yeah!<br /><br />But the funny thing about Scala, the really interesting thing — you guys are the first to hear my amazing insight on this, OK? — is:  it's put the Java people in a dilemma.  There's a reeeeeeeal problem.<br /><br />The problem is, the Java people say, "Well, dynamic languages, you know, suck, because they don't have static types." Which is kind of circular, right?  But what they mean, is they say:  No good tools, no good performance.  But even if you say, look, the tools and performance can get as good, they say, "Well, static types can help you write safer code!"<br /><br />It's... you guys know about those talismans?  The ones, where, "What's it for?"  "To keep tigers away"?  <em>(some chuckling)</em>  Yeah?  And you know, people are like, "How do you know it keeps tigers away?"  And your reply is: <em>(sneering)</em> "Do you see any tigers around here!?"  <em>(minor laughter)</em><br /><br />So this is what... OK, so for a long time, for many years... and you know, I've written more Java code than most Java programmers <em>ever</em> will. <em>(Editor's note:  nearly 1M lines in production.  Ouch.)</em>  So trust me.  I tried.  OK?  I'm not just coming in and saying "I don't want to learn Java."  No.  I know Java as well as the next person.<br /><br />But I come to them and say, let's do proof by – say, argument by example!  You know, an existence proof.  <a href="http://www.imdb.com/">IMDB</a> is written in Perl, right?  Yahoo! – many of their properties are written in PHP.  A lot of Microsoft stuff's written in VB, right?  ASP .NET?  Amazon.com's portal site is Perl/Mason.<br /><br />A lot of companies out there are building big, scalable systems – and I mean scalable in the sense of throughput and transactions, stuff like that, but also scalable in terms of human engineering — in these dynamic languages with no static types. [Using nothing more than good engineering principles.]<br /><br />So... isn't that a demonstration that you don't need the static types to keep those tigers away?<br /><br />And they're like:  "Well!  But!  What if... what if a tiger came?"  <em>(laughter)</em>  Right?  "People need shotguns in their house in case a bear comes through the door, right?"  The Simpsons made fun of that.  <em>(laughing continues)</em><br /><br />Yeah.  So, you know, for a long time, I was like: "Yeah, yeah, yeah.  OK.  So tigers could come.  Fine."<br /><br />Scala, now, is the tiger that's going to kill Java.  Because their [type-talisman] argument now has become a paradox, similar to the Paul Graham Blub Paradox thing, right?  Because they're like, "Well, we need static typing in order to engineer good systems.  It's simply not possible otherwise."<br /><br />The Scala people come in and they go:  "Your type system <em>suuuuuucks</em>.  It's not sound.  It's not safe.  It's not complete.  You're casting your way around it.  It doesn't actually prevent this large class of bugs.  How many times have you written <code>catch (NullPointerException x) ...</code> in Java?  Our type system doesn't allow [things like] that."<br /><br />Our type system does what <em>you</em> said <em>your</em> type system was doing.<br /><br />So, therefore, you should be using it!  ∴<br /><br />And the Java people look at it and go:  "Wehellll... <em>(cough cough)</em>... I mean, yeah, I mean... <em>(*ahem*)</em>" <em>(running finger under collar, as if sweating profusely)</em>  They say, "Welllll... you know... it's awfully... cummmmmbersome... I..."<br /><br />"We can actually get around the problems in practice that you guys say your type system is solving through Good Engineering Practices."<br /><br /><em>(laughter begins to grow)</em><br /><br />HA!!! <em>(I point accusingly at the audience, and there's more laughter)</em><br /><br />Yeah.<br /><br />So Scala is creating a real problem for [Java's] static typing camp now.  Because their last little bastion of why they're using it, the whole tigers argument, they're like, "Ah, well... we... we keep shotguns in our house."  [This is what they've been reduced to.]<br /><br />OK?  Yeeeeahhhh...<br /><br />So back to dynamic languages!<br /><br />But my point was — from a previous slide actually — it's very interesting.  See, I wrote this Rails port, and it wasn't... I never got it to where it was quite as succinct as Rails, because JavaScript has curly braces and a little bit of extra syntactic cruft.  But it was close!<br /><br />And then we used this framework to build this web app internally.  It was for external consumption.  It's kind of a long story that I won't go into.  But we had like 20 engineers on this thing, for close to a year.  And we had a huge application.  I mean in terms of user functionality:  Ajax-enabled pages, server-side persistence stuff... it was a big app.<br /><br />And it was, like 40,000 lines of code, including the templates and the client-side JavaScript.  The whole thing!  OK?  I mean, you add in unit tests, you know, you add in everything, including build files and stuff, and this thing was up to like, maybe 55,000 lines of code.<br /><br /><em>Thousand</em>.<br /><br />I mean, Java programmers would be saying, "We haven't hit 55 million yet.  <em>(Looking at feet)</em>  But, well... we're gonna."  <em>(laughter)</em><br /><br />And it's like, I tell 'em that <em>(shaking head)</em>, I tell 'em that, and they're like:  "Well."  <em>(avoiding eye contact)</em><br /><br />That's what they say.  "Well."<br /><br />And that's, you know, that's pretty much it. <em>(laughter)</em><br /><br /><b>Behind the Rhino</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQzglfAkI/AAAAAAAAAHk/97ER0XUIijs/s1600-h/rhino.010.jpg"><img style="cursor: pointer;" src="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQzglfAkI/AAAAAAAAAHk/97ER0XUIijs/s320/rhino.010.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879514625212994" border="1" /></a><br /><br />So unfortunately we have thirteen minutes left.  I'm sorry.  So let's really quickly go through some of the really cool things about Rhino, the technology here.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQ-Jsj8gI/AAAAAAAAAH0/-2KHP5e3ZYo/s1600-h/rhino.012.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQ-Jsj8gI/AAAAAAAAAH0/-2KHP5e3ZYo/s320/rhino.012.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879697459442178" border="1" /></a><br /><br />You can JavaScript from Java, and Java from JavaScript.  Guess which one's easier?<br /><br />Obviously calling Java from JavaScript is easier, because Java's really cumbersome.  It doesn't have anything to help you, so you have to do basically what I was talking about with Swing earlier.  <code>JavaScriptObject j = new JavaScriptObject()</code>  You know.  <code>JavaScriptObject, Context.enter!</code>  You've got all this <em>stuff</em> on the Java side.  'cuz it's Java.<br /><br />But, uh... but it works!  And you can do both directions.  Here's an example of a Java program to bootstrap... actually I believe this is completely standalone; it works out of the box.  It's a Rhino Demo:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/__0laCHgF5uc/SFRQ-RzlXTI/AAAAAAAAAH8/uBsWV-bYS_E/s1600-h/rhino.013.jpg"><img style="cursor: pointer;" src="http://1.bp.blogspot.com/__0laCHgF5uc/SFRQ-RzlXTI/AAAAAAAAAH8/uBsWV-bYS_E/s320/rhino.013.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879699636378930" border="1" /></a><br /><br />This is what you need to do to create a JavaScript object called <code>foo</code> that has a function called <code>a</code>.  A property called "<code>a</code>", sorry, whose value is "hello".<br /><br />So what you do is you call <code>Context.initStandardObjects()</code>, which sets up the JavaScript runtime.  You only have to do it once.  And then you call <code>newObject</code> to create a new JavaScript object.  And then you call <code>evaluateString</code> to evaluate it in the context of this object.<br /><br />It's one example of how you do it, but it's not too hard.  You can call back and forth.<br /><br />So that means that anything that was written in JavaScript that you feel, oh Gosh this really needs to be componentized, you need to stick it down in a Java library for whatever reason:  you can do it!  You can migrate code back and forth between the JavaScript layer and the Java layer.  This is true for all JVM languages, I think.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQ-lr2r_I/AAAAAAAAAIE/qyr07wtI2kc/s1600-h/rhino.014.jpg"><img style="cursor: pointer;" src="http://3.bp.blogspot.com/__0laCHgF5uc/SFRQ-lr2r_I/AAAAAAAAAIE/qyr07wtI2kc/s320/rhino.014.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879704972668914" border="1" /></a><br /><br />Uh... this is the actual code that I was referring to earlier, where you can define non-enumerable properties.  I called it <code>defineBuiltin</code>.  There's some closure stuff going on here... I don't want to bore you guys.  <em>(Editor's note:  <code>Function.bind()</code> based on Douglas Crockford's original)</em> <br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQ-9He1LI/AAAAAAAAAIM/DNZTPHU1j6A/s1600-h/rhino.015.jpg"><img style="cursor: pointer;" src="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQ-9He1LI/AAAAAAAAAIM/DNZTPHU1j6A/s320/rhino.015.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879711262561458" border="1" /></a><br /><br />Runtime delegation:  this is one of the reasons unit testing is really easy.  You guys know about Smalltalk, uh, method-missing?  [<code>doesNotUnderstand</code> actually]  It's <code>method_missing</code> in Ruby.  It's the... if you call an object — I think Objective C <a href="http://en.wikipedia.org/wiki/Objective-c#Forwarding">probably has something like this too</a>.<br /><br />You call an object, and you say:  "I'm calling <code>foo</code>", and it says:  "I don't have a <code>foo</code>".  Right?<br /><br />Normally, what happens when you do this?  In Java it goes *BARF*.  As it should, probably... <em>unless</em> what you really wanted to do was delegate to some other object.  Right?  "Design Patterns".  Say you want to write a Bridge that says:  "Oh!  You're calling <code>foo</code>, but you don't want to call it on me.  You want to go to the game server, call it there, marshal it, send it back.  We'll pretend it's a remote method call."<br /><br />Right?  There's a lot of stuff you've got to go through in Java to do stuff like this.  In JavaScript — as you all know, if you're using dynamic languages...<br /><br />Man, we've got a huge pool of people in the back.  It's getting pretty rough.  But we're almost out of time!  Fortunately.  Heh.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQ_DbVOBI/AAAAAAAAAIU/ezgerhrxs4w/s1600-h/rhino.016.jpg"><img style="cursor: pointer;" src="http://4.bp.blogspot.com/__0laCHgF5uc/SFRQ_DbVOBI/AAAAAAAAAIU/ezgerhrxs4w/s320/rhino.016.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879712956430354" border="1" /></a><br /><br />OK, so let me tell you a little bit about embedded XML.  It's kind of interesting, kinda neat.  This is supported in Firefox, in some browsers.  It's a spec that Adobe and some other people, <a href="http://en.wikipedia.org/wiki/E4X">BEA, put together</a>.<br /><br />And it's cool!  Because you can say stuff like<br /><br />  <code>var company = &lt;big xml thing&gt;</code><br /><br />Now of course there's this weird, big religious debate going on, between JSON advocates and XML advocates.  It's weird!  They're, like, locking horns.<br /><br />When I was a kid — when I was a kid, jeez...  When I was <em>twenty</em>, it feels like when I was a kid — I used to have tropical fish.  And my brothers and I noticed two things about tropical fish.<br /><br />One is that they die, because we're not in the tropics. <em>(some laughter)</em>  Sad.<br /><br />And the other is that if you put a bunch of different species of tropical fish in a tank together, they ignore each other... except for the ones that are the same [or nearly the same] species.  They bite each other.  That's what they do.  Fish bite each other.  They have a pecking order, right?<br /><br />JSON and XML are muscling in on each others' space, and there are bristles, OK, and it's so silly!  It's silly.  The whole thing, right?  I mean, XML is better if you have more text and fewer tags.  And JSON is better if you have more tags and less text.  Argh!  I mean, come on, it's that easy.  But you know, there's a big debate about it.<br /><br />Nevertheless, sometimes XML is appropriate [in JavaScript], especially if you're loading it from a file or whatever.  These literals are interesting.  And so it provides new operators and new syntax for actually going in and... it's kind of like XPath.  Except it's JavaScript-y.<br /><br />And I tell you:  it is the worst documented thing on the planet!  It's horrible, man, working with E4X initially.  But... eventually you can figure it out.  And I have a document that hopefully I'll be ready to release pretty soon, that actually covers it pretty well.  And Adobe has some good documentation for it.<br /><br />And then eventually it clicks, like learning any other language.  This is a minilanguage.  And you go:  "Ha, I get it!  I get it.  It's not as crazy and dumb as I thought.  It actually works."<br /><br />It's kind of a neat feature.  You guys know other languages that embed XML?  <a href="http://www.ibm.com/developerworks/library/x-scalaxml/">Scala does</a>.  I don't see all of you using that, but C# 3, I think, does XML?  Coming [soon]?  <em>(Editor's note:  it's apparently been deprioritized by the C# team, although VB 9 has them.)</em><br /><br />Anyway, it's kind of an interesting approach.<br /><br /><b>Inside the Rhino</b><br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRRQrYtXjI/AAAAAAAAAIc/PUjqqnFVrJs/s1600-h/rhino.017.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRRQrYtXjI/AAAAAAAAAIc/PUjqqnFVrJs/s320/rhino.017.jpg" alt="" id="BLOGGER_PHOTO_ID_5211880015740624434" border="1" /></a><br /><br />All right.  So this is Rhino.  Now you know.  After I explain this diagram, you'll know what you need to know about Rhino to talk to other people about it.<br /><br />You start with some JavaScript code.  It goes to a parser.  That turns it into a tree.  A syntax tree.<br /><br />Rhino's parser today, currently, immediately begins the next step of rewriting it as code generation.  Right away, as it's parsing.  Now this is a problem.  Because if it takes an if-statement or a switch-statement or a for-loop, and it generates sort of assembly-language like jumps to targets?  And generates labels, you know, converts it into sort of three-address code, that's eventually going to actually become three-address code:  assembly or bytecode.<br /><br />Then it kind of sucks if you're trying to use the parse tree for your IDE.  To, like, syntax highlight, or pretty-print, or show errors and warnings, or whatever.  Unfortunately a lot of languages — most languages — do this because they're written by compiler guys and compiler gals.  And they don't see the value.  But unfortunately we're all doing more and more processing of code.  Language tools, right?  Frontend stuff.<br /><br />So I rewrote Rhino's parser recently, and I'm currently fixing the code generator.  And I'm gonna get it out into the Rhino mainstream in a couple of weeks here.  Because my project at Google is doing a lot of code processing.  And it's a faithful representation.  So if your big beef about Rhino is that there's no Visitor over the AST:  I'm fixing that.<br /><br />And then there are two paths here:  you see one on the left that goes code generator to bytecode.  And there's the bytecode, or pseudo-bytecode, for the JavaScript code up there.  And then it goes to an interpreter.  The interpreter is a big loop.  Bytecode is this [roughly] postorder traversal of the tree, that flattens it in a way that allows you to push onto a stack to evaluate the operands.<br /><br />It's all actually very important; you should go <a href="http://en.wikipedia.org/wiki/Interpreter_%28computing%29">read up on how it works</a> if you're not familiar with it, or if you've forgotten since you first learned it.<br /><br />And the interpreter is actually pretty fast, because it's a loop.  There's not a lot of calling out.  I mean, there are some calls out into the runtime, but mostly it's this loop:  push, pop, push, pop.  So the JIT picks it up and can optimize it pretty well.<br /><br />The reason that there's two code paths here, the reason that they wrote the interpreter — they originally had just a classfile compiler — was that compiling to a classfile is this batch/static operation, where you want it [the resulting bytecode] to be fast.  You want to do the standard, classic compiler optimizations.  You want to generate the <a href="http://en.wikipedia.org/wiki/Control_flow_graph">control-flow graph</a>, you want to eliminate dead code, you want to do good register allocation.<br /><br />In JavaScript's case, it's often possible not to generate a closure.  You can actually use Java instance variables and Java local variables instead of these heavier-weight JavaScript [activation objects].  Because at the logical level, JavaScript doesn't really even have a stack.  It has object allocations on the heap; those are your Function invocations.  Sloooow.  Right?  Because [in comparison] the Java stack translates to the C stack.<br /><br />So the fact that the compiler can go through and optimize away a lot of this JavaScript dynamic stuff that's provable you're not gonna need, well, that's nice!  But it takes time.  The interpreter is a path that allows you to dynamically develop:  load code in and see how it's gonna work right now, at the unfortunate expense of the Rhino people having to maintain these two code paths.  But, you know, there's a lot shared between them.<br /><br />And that's it!  The script runtime implements all the JavaScript, you know, <a href="http://www.ecma-international.org/publications/standards/Ecma-252.htm">Ecma spec stuff</a>:  <code>Array</code>, <code>String</code>, <code>Boolean</code>, <code>Date</code>, the <code>Math</code> functions.  And a lot of it just delegates down to Java where possible.<br /><br />Pretty clean!  Pretty standard.  It's a pretty standard compiler, interpreter and runtime.  You're gonna see this if you dig into your favorite JVM language.  You'll probably see something similar to this.  This is actually more mature than a lot of them.  A lot of them start off by interpreting the parse tree, and it's slow from the method calls.<br /><br />So this is why Rhino's fast.  Now it could be a lot faster, and we're working on it.  Hopefully, you know, these things can be as fast as Java, in the same way that Java made the claim that it can be "as fast as C++".  And for long-running applications, that's usually true.  Especially with parallelism, right?  Threads.  And especially if the JIT has a chance to look at the actual code paths being used and compile them down into machine code <em>specific</em> for that code path, as a fall-through.<br /><br />Obviously for benchmarks, where they fire something up and run a loop a thousand times, or whatever?  C++ is faster because the JIT hasn't had any time to kick in and evaluate what's going on.  But for long-running services — which is what we're all writing, yeah?  At this Ajax conference — the JIT will kick in.  And your Rhino code now will get very close to where Java's performance is.  <em>(Provided you're not doing number-crunching - Ed.)</em>  So don't worry about that so much.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRRQ2jUfAI/AAAAAAAAAIk/eEdQJwjc0lA/s1600-h/rhino.018.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRRQ2jUfAI/AAAAAAAAAIk/eEdQJwjc0lA/s320/rhino.018.jpg" alt="" id="BLOGGER_PHOTO_ID_5211880018737921026" border="1" /></a><br /><br />So RnR, I already talked about it.  It doesn't have a database backend yet, because we're using Google's internal store, like Bigtables.  Which is why I haven't open-sourced the thing yet.<br /><br />It's weird:  somebody told me the other day, they sent me mail and said:  "I think you're today's Paul Graham".  And he meant this in the most negative connotation possible.  "You're today's Paul Graham, and RnR is the next Arc."<br /><br />I was like, "What!?"  And he said, well, he's a server-side JavaScript guy.  I mean, there aren't that many, right?  Most of us are thinking client-side.  But he's a server-side JavaScript guy.  And he goes to people and says, why aren't you using server-side JavaScript?  And they say:  "We're waiting for Steve Yegge to release RnR."<br /><br />And I'm... this is news to me!  I'm working on... stuff, you know.  Work.  And this [open-sourcing RnR] is part-time and everything.<br /><br />This year, now that we know people are interested in it, we will release it. <em>(At least we'll try for this year - Ed.)</em><br /><br />It's just a little weird, right?  Because Sun hired the JRuby guys, and they're doing <a type="amzn" asin="1590598814">JRuby on Rails</a>, and it's eventually going to be part of the Java Development Kit.  It's gonna be, you know:  it's Sun's lightweight answer to EJB and all those giant frameworks.  You want to build something quickly and use the Rails model, well, run Rails on the JVM!<br /><br />So I thought:  if JRuby on Rails had been (a) ready when we started using it [i.e. writing RnR], and (b) Google would let me use Ruby, then I would have used that!  So RnR was like a transitional thing.<br /><br />But... again, you know, I think that there are other people in situations where you really prefer to use JavaScript.  So yeah, I guess I'll... open-source it.  We're working on it.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/__0laCHgF5uc/SFRRRO-6MgI/AAAAAAAAAIs/V7ioXVPZ4eA/s1600-h/rhino.019.jpg"><img style="cursor: pointer;" src="http://1.bp.blogspot.com/__0laCHgF5uc/SFRRRO-6MgI/AAAAAAAAAIs/V7ioXVPZ4eA/s320/rhino.019.jpg" alt="" id="BLOGGER_PHOTO_ID_5211880025296089602" border="1" /></a><br /><br />This is the last slide, by the way; I know you guys are tired.  We're doing a lot of work on it.  I'm working on it personally, I mean working on Rhino.  Because I think it's all right.  I'm used to JavaScript now, and I think it's a good implementation.  It's a good compiler, so it's good practice for me, to learn how compilers work.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQyU4WbsI/AAAAAAAAAHU/2gxokh7U4mI/s1600-h/rhino.008.jpg"><img style="cursor: pointer;" src="http://2.bp.blogspot.com/__0laCHgF5uc/SFRQyU4WbsI/AAAAAAAAAHU/2gxokh7U4mI/s320/rhino.008.jpg" alt="" id="BLOGGER_PHOTO_ID_5211879494303248066" border="1" /></a><br /><br />We've got a debugger, but we're making the debugger better.  We've got a sandboxing model, but that could definitely be wrapped up and made available to you folks.<br /><br />We'd like to open-source our JSCompiler:  the thing that compresses JavaScript for Google Maps and GMail and stuff.  I know there are some open-source ones out there.  We don't think that it's competitively in our best interest to keep the thing internal.  It'd be better to get it out there so you all benefit from it, and so you can all hack on it, right?  We're working on open-sourcing our JSCompiler and other stuff.<br /><br />So that's it!  I wanted to cover Rhino, but I also wanted to leave time for questions.  And I've left you <em>(looking at big LED clock in the back)</em> one minute and sixteen seconds for questions.  Sorry about that.<br /><br />So really quickly, if there are any burning questions, I'll repeat the question and try to answer it.  Otherwise feel free to come up afterwards and chat.<br /><br /><b>Q&amp;A</b><br /><br /><b>Q:  Why won't Google let you use Ruby? </b><br /><br />Yeah, that's a good question.  Um... uh... I kinda <a href="http://steve-yegge.blogspot.com/2007/06/rhino-on-rails.html">wrote that up in a blog</a>.  Isn't that stupid?  "Read my blog!"<br /><br />The short answer is:  it imposes a tax on the systems people, which means that it's not completely self-contained within the team that's using it.  And for that reason, primarily, it's really not a good idea right now.<br /><br />Any other burning questions?<br /><br /><b>Q:  Do threads suck?</b><br /><br />Well, you know... they're... you know...  Yeah.  But I mean, what other options do you have?  I mean, you have multiprocessing/share-nothing, which is heavyweight and it requires more work.<br /><br />So I use threads.  I'd prefer something better, but they're what we've got today.<br /><br /><b>Q:  There are some guys that I work with, and one of their comments on JavaScript lately, since I've been wanting to use Rhino because I love JavaScript... what they brought up is that JavaScript is becoming a lot like Python, and that may or may not be such a great thing.  I wanted to know what you have to say about that.</b><br /><br />Ah.  OK.  Well, yeah, it already has borrowed some stuff from Python in <a href="http://developer.mozilla.org/en/docs/New_in_JavaScript_1.7">JavaScript 1.7</a>:  <code>yield</code>, Array comprehensions, destructuring assignment.  And these are good features.  They're good.  They're not going to change it to be syntactically whitespace sensitive, right?<br /><br />I don't know.  The guys working on it have really taken off in completely different directions from Python.  They're looking at an optional static type system, so in that sense it's maybe more like Groovy.  And they're looking at maybe fixing some of the bugs.<br /><br />But I don't know how that's going to evolve yet.  Because there's obviously a lot of people who have skin in the game, a lot of people interested in affecting the way the spec evolves.  So it's all kind of up in the air right now.<br /><br />All right, so we're really out of time.  I'd like to thank you for coming.  And please come up afterwards.  Thanks!<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/__0laCHgF5uc/SFRRRDK-hxI/AAAAAAAAAI0/Kx-ntD3EAp4/s1600-h/rhino.020.jpg"><img style="cursor: pointer;" src="http://1.bp.blogspot.com/__0laCHgF5uc/SFRRRDK-hxI/AAAAAAAAAI0/Kx-ntD3EAp4/s320/rhino.020.jpg" alt="" id="BLOGGER_PHOTO_ID_5211880022125479698" border="1" /></a>