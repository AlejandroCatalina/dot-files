<h1 id="background">Background</h1>

<p>In this blog I’m using <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> to convert Markdown to HTML.  It’s by far the
best and most powerful markdown converter, but it has one, albeit little
weakness: Its syntax highlighting is based <a href="http://hackage.haskell.org/package/highlighting-kate">highlighting-kate</a>, which is less
good and supports less languages than the Python library <a href="http://pygments.org/">Pygments</a>, the
de-facto standard highlighter used by Github and others.</p>

<p>Fortunately, it’s easy to implement custom highlighting thanks to the great API
of Pandoc, with just two functions in
<a href="https://github.com/lunaryorn/blog/blob/f9c1c518bb140d25a49ca2592d8664a43c67ff6f/src/Text/Highlighting/Pygments/Pandoc.hs"><strong>Text.Highlighting.Pygments.Pandoc</strong></a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Text.Highlighting.Pygments</span> <span class="p">(</span><span class="nf">toHtml</span><span class="p">)</span>

<span class="n">blockToHtml</span> <span class="o">::</span> <span class="kt">Block</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">Block</span>
<span class="n">blockToHtml</span> <span class="n">x</span><span class="o">@</span><span class="p">(</span><span class="kt">CodeBlock</span> <span class="n">attr</span> <span class="kr">_</span><span class="p">)</span> <span class="o">|</span> <span class="n">attr</span> <span class="o">==</span> <span class="n">nullAttr</span> <span class="o">=</span> <span class="n">return</span> <span class="n">x</span>
<span class="n">blockToHtml</span> <span class="n">x</span><span class="o">@</span><span class="p">(</span><span class="kt">CodeBlock</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="kt">[]</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">return</span> <span class="n">x</span>
<span class="n">blockToHtml</span> <span class="p">(</span><span class="kt">CodeBlock</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span><span class="n">language</span><span class="o">:</span><span class="kr">_</span><span class="p">,</span><span class="kr">_</span><span class="p">)</span> <span class="n">text</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">colored</span> <span class="o">&lt;-</span> <span class="n">toHtml</span> <span class="n">text</span> <span class="n">language</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">RawBlock</span> <span class="p">(</span><span class="kt">Format</span> <span class="s">"html"</span><span class="p">)</span> <span class="n">colored</span><span class="p">)</span>
<span class="n">blockToHtml</span> <span class="n">x</span> <span class="o">=</span> <span class="n">return</span> <span class="n">x</span>

<span class="n">codeBlocksToHtml</span> <span class="o">::</span> <span class="kt">Pandoc</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">Pandoc</span>
<span class="n">codeBlocksToHtml</span> <span class="o">=</span> <span class="n">walkM</span> <span class="n">blockToHtml</span>
</code></pre>
</div>

<p>This code transforms all code blocks to a raw HTML block containing the code
highlighted by Pygments.  The language used in the code block is taken from the
first unnamed attribute of the code block, just like in Github’s markdown
dialect.  Code blocks which do not specify a language are not touched.</p>

<p>So far I just went the easy way, and called the
<a href="http://pygments.org/docs/cmdline/"><code class="highlighter-rouge">pygmentize</code> script</a> in <code class="highlighter-rouge">toHtml</code>, passing the code to be
highlighted on stdin, and reading the result from stdout.  While this is easy to
implement with just a few lines, it’s also very, very slow.</p>

<p>Last weekend I sat down and tried to call Pygments directly via Python’s C API
through Haskell’s FFI.  This is what came out of this attempt.</p>

<h1 id="native-wrappers">Native wrappers</h1>

<p><a href="https://github.com/lunaryorn/blog/blob/e0d3faa6d95cb567d7356dec902575691051b5a5/src/Foreign/Python/Native.hsc"><strong>Foreign.Python.Native</strong></a> is an <a href="http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/hsc2hs.html">hsc2hs</a> module which imports the
required functions from Python’s C API and declares corresponding Haskell
signatures.</p>

<p>The module also declares the necessary types, using a special <code class="highlighter-rouge">hsc2hs</code> feature
to automatically derive the right Haskell type for a given C type.  For
instance, the following declaration declares an appropriate Haskell alias for
Python’s <code class="highlighter-rouge">Py_ssize_t</code>, so I didn’t need to grok the header files for the
typedef:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">PySSizeT</span> <span class="o">=</span> <span class="o">#</span><span class="kr">type</span> <span class="kt">Py_ssize_t</span>
</code></pre>
</div>

<p>I also use the <code class="highlighter-rouge">CApiFFI</code> extension to avoid the hassle of finding out whether to
import the UCS2 or the UCS4 API of CPython.  Instead, I just import the macro
API and let GHC figure out the rest:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">foreign</span> <span class="kr">import</span> <span class="nn">capi</span> <span class="n">unsafe</span> <span class="s">"Python.h PyUnicode_AsUTF8String"</span>
  <span class="n">pyUnicode_AsUTF8String</span> <span class="o">::</span> <span class="kt">RawPyObject</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">RawPyObject</span>

<span class="n">foreign</span> <span class="kr">import</span> <span class="nn">capi</span> <span class="n">unsafe</span> <span class="s">"Python.h PyUnicode_FromStringAndSize"</span>
  <span class="n">pyUnicode_FromStringAndSize</span> <span class="o">::</span> <span class="kt">CString</span> <span class="o">-&gt;</span> <span class="kt">PySSizeT</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">RawPyObject</span>
</code></pre>
</div>

<p>GHC automatically generates a wrapper C functions for these macros, and figures
out whether to link <code class="highlighter-rouge">PyUnicodeUCS2_AsUTF8String</code> or
<code class="highlighter-rouge">PyUnicodeUCS4_AsUTF8String</code>.</p>

<h1 id="convenient-haskell-api">Convenient Haskell API</h1>

<p><a href="https://github.com/lunaryorn/blog/blob/e0d3faa6d95cb567d7356dec902575691051b5a5/src/Foreign/Python.hs"><strong>Foreign.Python</strong></a> is the convenient Haskell API around the
<a href="#native-wrappers">native Python functions</a>.</p>

<hr />

<p><strong>Update</strong> <em>(April 16, 2014)</em>: I changed <code class="highlighter-rouge">toPyObject</code> to return <code class="highlighter-rouge">Nothing</code> if
given a null pointer, for increased safety.  Previously <code class="highlighter-rouge">toPyObject</code> would
simply wrap the given pointer, whether <code class="highlighter-rouge">NULL</code> or not.  The definition of
<code class="highlighter-rouge">toPyObjectChecked</code> was updated accordingly.</p>

<p>While wrapping a <code class="highlighter-rouge">NULL</code> pointer in a managed pointer doesn’t do any harm in and
by itself, because the dereferencing functions from Python are safe to call with
<code class="highlighter-rouge">NULL</code>, it was still possible to try and use the pointer, e.g. by trying to call
the underlying Python object, and thus trigger a segfault.</p>

<p>Now it’s impossible to obtain a <code class="highlighter-rouge">PyObject</code> from <code class="highlighter-rouge">NULL</code>, increasing the safety of
my Python API.</p>

<hr />

<p>I use <code class="highlighter-rouge">ForeignPtr</code> to wrap the raw <code class="highlighter-rouge">PyObject</code> pointers into an opaque Haskell
type which automatically calls <code class="highlighter-rouge">Py_XDECREF</code> on the underlying <code class="highlighter-rouge">PyObject</code> when it
goes out of scope:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">PyObject</span> <span class="o">=</span> <span class="kt">PyObject</span> <span class="p">(</span><span class="kt">ForeignPtr</span> <span class="nb">()</span><span class="p">)</span>

<span class="n">toPyObject</span> <span class="o">::</span> <span class="kt">RawPyObject</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">PyObject</span><span class="p">)</span>
<span class="n">toPyObject</span> <span class="n">raw</span> <span class="o">|</span> <span class="n">raw</span> <span class="o">==</span> <span class="n">nullPtr</span>  <span class="o">=</span> <span class="n">return</span> <span class="kt">Nothing</span>
<span class="n">toPyObject</span> <span class="n">raw</span> <span class="o">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">.</span> <span class="kt">PyObject</span><span class="p">)</span> <span class="p">(</span><span class="n">newForeignPtr</span> <span class="n">pyDecRef</span> <span class="n">raw</span><span class="p">)</span>

<span class="n">withPyObject</span> <span class="o">::</span> <span class="kt">PyObject</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">RawPyObject</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="n">withPyObject</span> <span class="p">(</span><span class="kt">PyObject</span> <span class="n">ptr</span><span class="p">)</span> <span class="o">=</span> <span class="n">withForeignPtr</span> <span class="n">ptr</span>
</code></pre>
</div>

<p>Only the opaque type is exported from the module, so outside code never has any
chance of messing with the underlying C object and bypassing the garbage
collector.</p>

<p>Many CPython functions return <code class="highlighter-rouge">NULL</code> to indicate that the operation failed and a
Python exception was raised.  To deal with these situations I use a little
helper that throws a Haskell exception from the current Python exception if
given a <code class="highlighter-rouge">NULL</code> pointer:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">toPyObjectChecked</span> <span class="o">::</span> <span class="kt">RawPyObject</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
<span class="n">toPyObjectChecked</span> <span class="o">=</span> <span class="n">toPyObject</span> <span class="o">&gt;=&gt;</span> <span class="n">maybe</span> <span class="n">throwCurrentPythonException</span> <span class="n">return</span>
</code></pre>
</div>

<p>To obtain objects from the Python runtime, I define a bunch of functions to
import modules, get attributes and call objects.  The implementations are mostly
boilerplate code, so I’ll just show you the type signatures:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">importModule</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
<span class="n">getAttr</span>      <span class="o">::</span> <span class="kt">PyObject</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
<span class="n">callObject</span>   <span class="o">::</span> <span class="kt">PyObject</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">PyObject</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[(</span><span class="kt">PyObject</span><span class="p">,</span> <span class="kt">PyObject</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
</code></pre>
</div>

<p>To convert these objects from Haskell, and to pass Haskell objects to Python, I
use a little type class to convert a type to and from Python:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Object</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">toPy</span>   <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">PyObject</span>
  <span class="n">fromPy</span> <span class="o">::</span> <span class="kt">PyObject</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
</code></pre>
</div>

<p>As I only need strings to call Pygments, there are only two instances for
<code class="highlighter-rouge">ByteString</code> and <code class="highlighter-rouge">String</code>.</p>

<p>To convert from a <code class="highlighter-rouge">ByteString</code>, I just need to obtain a temporary buffer from
the byte string and pass that to Python:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Object</span> <span class="kt">ByteString</span> <span class="kr">where</span>
  <span class="n">toPy</span> <span class="n">s</span> <span class="o">=</span> <span class="n">useAsCStringLen</span> <span class="n">s</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">pyString_FromStringAndSize</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">toPyObjectChecked</span>
</code></pre>
</div>

<p>Converting back to a is a little more intricate, because Python needs
addressable fields to take the raw bytes out of the underlying <code class="highlighter-rouge">PyObject</code>.
Fortunately <code class="highlighter-rouge">Foreign.Marshal.Alloc.alloca</code> comes to rescue and conveniently
allocates addressable fields which I can then hand down to Python.  Python puts
the address and size of the underlying string buffer into these fields, which I
can then read with <code class="highlighter-rouge">Foreign.Storable.peek</code> to copy the entire byte sequence into
an independent <code class="highlighter-rouge">ByteString</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  <span class="n">fromPy</span> <span class="n">s</span> <span class="o">=</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s_buffer_ptr</span> <span class="o">-&gt;</span>
    <span class="n">alloca</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s_len_ptr</span> <span class="o">-&gt;</span>
    <span class="n">withPyObject</span> <span class="n">s</span> <span class="o">$</span> <span class="nf">\</span><span class="n">raw</span> <span class="o">-&gt;</span> <span class="kr">do</span>
      <span class="n">result</span> <span class="o">&lt;-</span> <span class="n">pyString_AsStringAndSize</span> <span class="n">raw</span> <span class="n">s_buffer_ptr</span> <span class="n">s_len_ptr</span>
      <span class="n">unless</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">throwCurrentPythonException</span>
      <span class="n">buffer</span> <span class="o">&lt;-</span> <span class="n">peek</span> <span class="n">s_buffer_ptr</span>
      <span class="n">len</span> <span class="o">&lt;-</span> <span class="n">peek</span> <span class="n">s_len_ptr</span>
      <span class="n">packCStringLen</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span>
</code></pre>
</div>

<p>Converting from a <code class="highlighter-rouge">String</code> almost looks like converting from a <code class="highlighter-rouge">ByteString</code>,
except that we need to encode the <code class="highlighter-rouge">String</code> to UTF-8 to pass it to
<code class="highlighter-rouge">PyUnicode_FromStringAndSize</code>, which expects a UTF-8 encoded char array.
Converting back is simple as well, because I can build upon the <code class="highlighter-rouge">ByteString</code>
conversion from above. I just need to turn the Python unicode object into an
encoded char array with <code class="highlighter-rouge">PyUnicode_AsUTF8String</code> which I can then convert to a
<code class="highlighter-rouge">ByteString</code> and decode:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Object</span> <span class="kt">String</span> <span class="kr">where</span>
  <span class="n">toPy</span> <span class="n">s</span> <span class="o">=</span> <span class="n">useAsCStringLen</span> <span class="p">(</span><span class="kt">UTF8</span><span class="o">.</span><span class="n">fromString</span> <span class="n">s</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">pyUnicode_FromStringAndSize</span> <span class="n">buffer</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">toPyObjectChecked</span>
  <span class="n">fromPy</span> <span class="n">o</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="o">&lt;-</span> <span class="n">withPyObject</span> <span class="n">o</span> <span class="n">pyUnicode_AsUTF8String</span> <span class="o">&gt;&gt;=</span> <span class="n">toPyObjectChecked</span>
    <span class="n">liftM</span> <span class="kt">UTF8</span><span class="o">.</span><span class="n">toString</span> <span class="p">(</span><span class="n">fromPy</span> <span class="n">s</span><span class="p">)</span>
</code></pre>
</div>

<h1 id="pygments-interface">Pygments interface</h1>

<p><a href="https://github.com/lunaryorn/blog/blob/36bef7de1a7914fa4bffdd28800dbd01f6ca719a/src/Text/Highlighting/Pygments.hs"><strong>Text.Highlighting.Pygments</strong></a> is the Pygments interface that builds upon
this <a href="#convenient-haskell-api">Python API</a>.</p>

<p>I start with some type aliases for Pygments types.  They don’t add additional
type safety, because Python is dynamically typed anyway, but they make the type
signatures a little nicer:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">Lexer</span>     <span class="o">=</span> <span class="kt">PyObject</span>
<span class="kr">type</span> <span class="kt">Formatter</span> <span class="o">=</span> <span class="kt">PyObject</span>
</code></pre>
</div>

<p>Then I wrap the required functions from Pygments into convenient Haskell
functions. <code class="highlighter-rouge">getLexerByName</code> gives me the Pygments Lexer for the name of a
programming language:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">getLexerByName</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">Lexer</span>
<span class="n">getLexerByName</span> <span class="n">name</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">initialize</span> <span class="kt">False</span>
  <span class="n">lexers</span> <span class="o">&lt;-</span> <span class="n">importModule</span> <span class="s">"pygments.lexers"</span>
  <span class="n">get_lexer_by_name</span> <span class="o">&lt;-</span> <span class="n">getAttr</span> <span class="n">lexers</span> <span class="s">"get_lexer_by_name"</span>
  <span class="n">pyName</span> <span class="o">&lt;-</span> <span class="n">toPy</span> <span class="n">name</span>
  <span class="n">callObject</span> <span class="n">get_lexer_by_name</span> <span class="p">[</span><span class="n">pyName</span><span class="p">]</span> <span class="kt">[]</span>
</code></pre>
</div>

<p>The function</p>

<ol>
  <li>initializes the interpreter,</li>
  <li>imports <code class="highlighter-rouge">pgyments.lexers</code>,</li>
  <li>gets a reference to the underlying <code class="highlighter-rouge">get_lexer_by_name</code> function,</li>
  <li>converts the given <code class="highlighter-rouge">language</code> to a Python object,</li>
  <li>and ultimately calls <code class="highlighter-rouge">get_lexer_by_name</code> with the appropriate arguments.</li>
</ol>

<p>Note that this function is as safe as it can be when dealing with a dynamically
typed language:</p>

<ul>
  <li>It will never try to use invalid objects, because Python operations never fail
silently.  If any Python call fails, e.g. because Pygments is not installed,
the Python interface throws a Haskell exception.</li>
  <li>Even in case of an exception, the function does not leak memory.  All
references to Python objects are managed pointers which automatically free the
underlying Python object when they go out of scope, whether by a normal
return, or in case of an exception.</li>
</ul>

<p><code class="highlighter-rouge">highlight</code> highlights a given piece of code with a lexer and formatter:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">highlight</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Lexer</span> <span class="o">-&gt;</span> <span class="kt">Formatter</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">highlight</span> <span class="n">code</span> <span class="n">lexer</span> <span class="n">formatter</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">initialize</span> <span class="kt">False</span>
  <span class="n">pygments</span> <span class="o">&lt;-</span> <span class="n">importModule</span> <span class="s">"pygments"</span>
  <span class="n">py_highlight</span> <span class="o">&lt;-</span> <span class="n">getAttr</span> <span class="n">pygments</span> <span class="s">"highlight"</span>
  <span class="n">codeObj</span> <span class="o">&lt;-</span> <span class="n">toPy</span> <span class="n">code</span>
  <span class="n">callObject</span> <span class="n">py_highlight</span> <span class="p">[</span><span class="n">codeObj</span><span class="p">,</span> <span class="n">lexer</span><span class="p">,</span> <span class="n">formatter</span><span class="p">]</span> <span class="kt">[]</span> <span class="o">&gt;&gt;=</span> <span class="n">fromPy</span>
</code></pre>
</div>

<p>With these convenient wrappers I am now able to implement <code class="highlighter-rouge">toHtml</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">toHtml</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">toHtml</span> <span class="n">code</span> <span class="n">language</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">formatters</span> <span class="o">&lt;-</span> <span class="n">importModule</span> <span class="s">"pygments.formatters"</span>
  <span class="n">html_formatter</span> <span class="o">&lt;-</span> <span class="n">getAttr</span> <span class="n">formatters</span> <span class="s">"HtmlFormatter"</span>
  <span class="n">cssclass_key</span> <span class="o">&lt;-</span> <span class="n">toPy</span> <span class="s">"cssclass"</span>
  <span class="n">cssclass</span> <span class="o">&lt;-</span> <span class="n">toPy</span> <span class="s">"highlight"</span>
  <span class="n">formatter</span> <span class="o">&lt;-</span> <span class="n">callObject</span> <span class="n">html_formatter</span> <span class="kt">[]</span> <span class="p">[(</span><span class="n">cssclass_key</span><span class="p">,</span> <span class="n">cssclass</span><span class="p">)]</span>
  <span class="n">lexer</span> <span class="o">&lt;-</span> <span class="n">getLexerByName</span> <span class="n">language</span>
  <span class="n">highlight</span> <span class="n">code</span> <span class="n">lexer</span> <span class="n">formatter</span>
</code></pre>
</div>

<p>This function first creates an instance of the <code class="highlighter-rouge">HtmlFormatter</code> class, by
importing the <code class="highlighter-rouge">pygments.formatters</code> module, obtaining a reference to the class
object, and calling the class object with some options to create a new instance.</p>

<p>Then it gets the lexer object, and passes these objects and the code to
<code class="highlighter-rouge">highlight</code>.  The result is a string containing HTML to highlight the given
<code class="highlighter-rouge">code</code>.</p>

<h1 id="building">Building</h1>

<p>I use Cabal to build these modules.  The corresponding <a href="https://github.com/lunaryorn/blog/blob/306c891845311a8a4e424cabfade4db07318c603/lunarsite.cabal">cabal file</a> is simple:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>executable lunarsite
  […]
  other-modules:       Foreign.Python
                       Foreign.Python.Native
                       Text.Highlighting.Pygments
                       Text.Highlighting.Pygments.Pandoc
  build-depends:       base &gt;=4.6 &amp;&amp; &lt;4.8,
                       bytestring &gt;=0.10 &amp;&amp; &lt; 0.11,
                       utf8-string &gt;=0.3 &amp;&amp; &lt;0.4,
                       pandoc-types &gt;=1.12 &amp;&amp; &lt;1.13,
                       pandoc &gt;=1.12 &amp;&amp; &lt;1.13
  build-tools:         hsc2hs

  if os(darwin)
     extra-libraries:   python2.7
     include-dirs:      /usr/include/python2.7
  else
     pkgconfig-depends: python ==2.7
</code></pre>
</div>

<p>I enable <code class="highlighter-rouge">hsc2hs</code> in <code class="highlighter-rouge">build-tools</code> to compile
<a href="#native-wrappers">Foreign.Python.Native</a>, and tell Cabal to link against Python
2.7.</p>

<p><code class="highlighter-rouge">pkg-config</code> is missing on OS X, but since the layout of the pre-installed
system Python is fixed anyway, I just hard-code the library name and the include
directory.</p>

<p>On other systems I just rely on Cabal’s built-in support for <code class="highlighter-rouge">pkg-config</code> to
automatically determine the library name and the include directories for Python
2.7.</p>

<h1 id="lessons-learned">Lessons learned</h1>

<p>Calling Python from Haskell was much, much easier than I thought, thanks to
Haskell’s good FFI, which takes over all marshaling of primitive types, and
provides great utilities and helpers to marshal complex types.</p>

<p>It would even been even easier, however, if the C API of Python 2.7 was a little
better, and had a little more consistent reference count semantics, and if
Haskell supported varargs functions in its FFI.</p>

<p>While Python functions normally do not steal references and do not return
borrowed references, there are some notable exceptions, which lead the entire
attempt to provide a consistent API ad absurdum, since you still need to check
any function carefully for how it handles the reference counts in its arguments
and return values.</p>

<p>And since Haskell doesn’t support foreign varargs functions, I frequently had to
manually assemble complex Python objects such as argument tuples using the
lower-level API, instead of just calling <a href="https://docs.python.org/2/c-api/arg.html#Py_BuildValue"><code class="highlighter-rouge">Py_BuildValue</code></a> to build complex
Python objects from C values directly.</p>

<p>Despite these minor nuisances working with Haskell’s FFI has been a really
pleasant experience so far, and I’m truly surprised that a language which is
generally renowned for its advancement of computer science also excels at the
dirty low-level task of calling C libraries.</p>