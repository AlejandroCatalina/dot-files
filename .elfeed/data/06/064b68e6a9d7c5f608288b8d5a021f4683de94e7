<style>
table {
    margin-left: 45px;
    font-family: courier;
    font-size: 8px;
    line-height: 1em !important;
}
.group0 {
    color: #000
}
.group1 {
    color: #f00
}
.group2 {
    color: #0f0
}
.group3 {
    color: #00f
}
.group4 {
    color: #ff0
}
.group5 {
    color: #0ff
}
</style>

<p>Click the table of zeroes once. Note that the text input field remains
responsive even as we run 100,000 updates on the DOM. The colors of
the table show the render batching boundaries. Note, I would not try
this on a mobile device ;)</p>

<div style="text-align: center; margin-bottom: 25px;">
    <input />
</div>

<table id="big-table" cellpadding="0" cellspacing="0"></table>

<script type="text/javascript" src="/assets/js/csp3.js"></script>

<p>The following is all the code we need to write a batching render with
a flush in milliseconds set by <code>rate</code>. We&#39;ve intentionally set a
relatively small buffer size, as we increase the buffer size the table
will update in larger and larger chunks.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(defn render-loop [rate]
  (let [in (chan 1000)]
    (go (loop [refresh (timeout rate) queue []]
          (let [[v c] (alts! [refresh in])]
            (condp = c
              refresh (do (render! queue)
                        (recur (timeout rate) []))
              in (recur refresh (conj queue v))))))
    in))
</code></pre></div>
<p>Fun stuff.</p>
